Notes for Unit 11 Subunit 13

			11.13.1
			Trees Handout
			https://lessons.springboard.com/Trees-Binary-Trees-d82169f465cc42b883276a226825daac
**Concerning Trees
**Goals
	1.) Introduce terminology
	2.) Create a tree class and methods
	3.) Learn uses for trees

**Terminology
	1.) Node: basic unit
	2.) Children: nodes directly below a node
	3.) Descendants: nodes below a node
	4.) Parent: node that is directly above a node
	5.) Ancestor: node that is above a node
	6.) Root Node: node at the top of tree
	7.) Leaf Node: node without any children

**Information about Binary Trees and Other Trees
	--What are they?
	--What are they good for?
	--Advanced Ideas

			11.13.2
			Intro to Trees
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64629

**Trees are not actually new. We have worked with them, we just have called them trees
**Goals:
	1.) Introduce terminology
	2.) Create a tree class and methods
	3.) Learn uses for trees

**JS Trees are like an upside down version of a tree in nature
	--they are similar
	--both have roots and branches
	--branches can split and split and split
	--both have leaves
**In general
	--a JS tree has a root node at the top

**Types of trees
	1.) Organization Chart
	2.) Filesystem of a computer
	3.) HTML DOM (writing HTML code)
		--this gets pretty in depth
		--as we know, HTML docs are trees
		--for example, the body of an HTML would be the root node
		--and each element inside the body would be a child, an ancestor, a descendant or a parent
		--we can look up these nodes in JS
		**Example:

	document.documentElement.children
		--in the console, this would bring up an array containing head and body
	document.documentElement.children[0]	
		--this would take us into the head element
	document.documentElement.children[1]
		--this would take us into the body element
	4.) Taxonomy (classifying organisms in Biology)

**Requirements for trees
	--if it does NOT have a root node, it is not a tree
	--a node can only have one parent
	**Example using Taxonomy

|--Organisms
|__Kingdom
	|--plants
	|--fungi
	|--animals
		|__Phylum
			|--cnidaria
			|--molluscs
			|--chordata
				|__Class
					|--actinopterygii
					|--mammalia
						|__Order
							|--carnivora
							|--primate
							|--artiodactyla
							|--rodentia
					|--chondrichthyes
					|--aves
					|--amphibia
					|--reptilia
	--in the above example, we have a root node (organisms)
	--then we have multiple parents growing from that root node
	--for example, mammalia is the parent of 4 children
	--chordata is the parent of 6 children and so on
	--each child can only have one parent
	--each parent can have multiple children



			11.13.3
			Tree Terminology
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64629

**Example of a Tree

|--Amy
	|--Bob
		|--Carol
			|--Daniel
				|--Edward
				|--Eric
			|--Derick
	|--Barb
		|--Carlos
		|--Connie
			|--Darlene
			|--David
				|--Ellen
				|--Erica
	|--Barry
		|--Consuela

**Nodes
	--nodes are every element of a tree
	--so each name in the example is a node
	--just like a linked list (every element in an li is a node)
**Children:
	--any node directly below another node
	--in the example, Bob, Barb and Barry are all children of Amy
**Descendants:
	--any node that is not a direct child of another node
	--In the example, Daniel would NOT be a child of Bob, he would be a descendant
**Parent:
	--a node directly above another node
	--in the example, Amy is a parent of Bob, Barb and Barry
	--Bob is a parent of Carol
	--Carol is a parent of Daniel	
**Ancestor:
	--in the example, Amy would be an ancestor of Connie
	--Connie would be an ancestor Erica and so on
**Root Node:
	--a root node is the very top of the tree (Amy in the example)
	--to be considered a tree, you NEED a root node
**Leaf Node:
	--a leaf node is a node without children (the final node of a branch)
	--in the example, Consuela is a leaf node
	--Erica is a leaf node and so on
**Binary Trees:
	--in a binary tree there are rules about how many children a parent can have
	--AT MOST, the node of a binary tree can have 2 children (hence the name binary)
	--the tree examples we have been looking at have nodes with more than 2 children
**Other types of trees
	--Quad tree
		--each node has exactly 4 children
	--Oct Tree
		--each node has 8 children at most
**Trees
	--general tree structures are sometimes referred to as "Anary Trees"
		--this means there is no constraint on how many children a node can have



			11.13.4
			Implementing a Tree
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64629

**Let's see how we can implement a general tree structure in JS
	**Example:

class Node {
    constructor(){
        this.val = val
        this.right = null;
        this.left = null;
    }
}
	--this wouldn't work unless we knew it was a binary tree, because we have this.val for each node
	--then we have this.left for one child and this.right for the next
	--this would not work for a general "n-ary" tree
	--we could make this work by hard coding each node
	--even then, there would be cap on how many children each node could have
	--we can solve this by using an array
	**Example:

class Node {
    constructor(val){
        this.val = val
        this.children = []
    }
}

let amy = new Node ('Amy')
let bob = new Node ('Bob')
let barb = new Node ('Barb')
let barry = new Node ('Barry')

amy.children.push(bob)
amy.children.push(barb)
amy.children.push(barry)
	--here we are adding children to our root node (amy)
	--this will give us a simple tree structure
	--if console.log amy we see that amy is a root node with 3 children
	--each child has 0 children, so they are considered leaf nodes
	--we could also write this so that our constructor will accept children right off the bat
	**Example:

class Node {
    constructor(val, children=[]){
        this.val = val
        this.children = children
    }
}

let amy = new Node('amy', [new Node('Bob'), new Node('Barb'), new Node('Barry')])
console.log(amy)
	--this will give us the same structure as before, but with simplified code
	--let's do DOM (domain) example 
	**Example:

let htmlEl = new Node('html', 
	[new Node('head', 
		[new Node('title')]), 
    new Node('body', 
	[new Node('ul', 
		[new Node('li'), new Node('li2')])])])
	--here we have a root node of html
	--html has 2 children (head and body)
	--head has 1 child (title)
	--body has 1 child (ul)
	--ul has 2 children (li and li2)

**Next we will talk about traversing a tree



			11.13.5
			Depth First Search
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64633

**Tree Traversal
	--has to do with finding nodes
	--usually starts with the root node
	--using code, how do we find things that may  be hundreds or thousands of layers deep?
**Two types of traversal
	1.) Breadth First Search
		--this method is searching "across" a tree
		--so starting at the root node and then moving through each child of that root node
	2.) Depth First Search
		--this method is searching down the tree
		--so you would start at the root, then go to the first child and the children of the first child
		--then to the children of the children of the first child and so on
	**The question remains, do we go as broad as possible or as deep as possible to start
		--either way we need a way to keep track of or store the nodes we have yet to visit
		--unlike a linked list where we can .next through it, we cannot do the same with a tree
	**Example:

1 class Node {
2    constructor(val, children=[]){
3        this.val = val
4        this.children = children
5    }
6    find(val){
7        const toVisitStack = [this];
8        while(toVisitStack.length){
9            const current = toVisitStack.pop();
10            if(current.val === val){
11                return current;
12            }
13            for(let child of current.children){
14                toVisitStack.push(child)
15            }
16        }
17    }
18 }
19
20 let htmlEl = new Node('html', [
21    new Node('head', [new Node('title')]), 
22    new Node('body', [new Node('ul', [new Node('li'), new Node('li2')])])
23 ]);
24
25 console.log(htmlEl.find('div'))
	**lines 20 to 23 have the code for the tree that we are attempting to find the li element in

**Here's a thorough explanation of what the heck is happening up there:
	--let's say we're trying to find 'li' in this tree
	--so htmlEl.find('li')
	--line 6 is obviously the name of our function
	--in line 7 we start by making our stack which is an array containing 'this'
		--this will refer to whatever we called find on
		--so in the beginning the stack looks like this [{val: 'html', children: [other things]}]
	--line 8 is checking if there is a length to the stack that we just created
	--if there is, line 9 will pop something off of the stack
		--still on line 9, the thing we pop off is stored to the variable 'current'
	--line 10 we are checking if the current element that we have in the 'current' variable is equal to what we want to find
		--val in line 10 is referring to whatever html element we may be looking for
		--if the line 10 statement returns false, the return value in the function does not run
	--line 13/14 are pushing each child from the element we are currently on (html) onto the toVisitStack
		--so in our example, we have 2 children from the 'html' root node (head and body)
		--these children are what is put into the stack
	**Visual Example:
	--after one time through the tree, this is how we could picture the result
		stack: ['head', 'body']
		current: ['html']
			--html is the node that we are currently looking through and is stored in the 'current' variable
			--head and body are the children of html so they are stored in the toVisitStack, stack
	--then everything starts over until we find the element we are looking for
	--once we start again, we pop off the most recently added thing from the stack (body in this case)
	--body is then stored in the 'current' variable
	--body is then the current value and NOT equal to the element we want to find
	--so the children of the body node are pushed onto the stack
	**Visual Example:
		stack: ['head', 'ul']
		current: [body]
			--because head is in the stack, it will be searched if we don't find 'li' in the children or descendants or ancestors of body\
	--ul is not equal to li
	--so we pop ul from stack and push to current
	--then we push li and li2 to the stack
	**Visual Example:
		stack: ['head', 'li', 'li2']
		current: ['ul']
	--li2 (the most recent addition to the stack) is also not equal to li
	--so we pop li2 from the stack and push it current
	**Visual Example:
		stack: ['head', 'li']
		current: ['li2']
	--there are no children of li2, so we repeat the process with li
	--first we pop li from stack and push it to current
	--li makes our equality statement true so current (which holds li) is returned
**Important Note about This process:
	--the first thing that happens in each step of this process, is we check to see if there is still a length to the stack
	--if there is nota length to the stack, it means what we're trying to find doesn't exist in our tree
	--if there is a length to the stack, it means that we just haven't found what we're searching for yet
**this is one implementation of traversing through a tree
	--the way we accomplished this is called depth first search (uses stack)



			11.13.6
			Breadth First Search
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64633

**Depth first search uses a stack
	--breadth first search does not use a stack
**Why breadth first?

						Amy
			Bob				Barb					Barry
		Carol				Carlos		Connie					Consuela
Daniel			Derick					Darlene	David
Edward	Eric								Ellen Erica
	--using the tree from above, let's say we have multiple Consuela's and we want to find the highest ranking Consuela
	--depth first wouldn't be useful, because we would be moving all the way down a branch and finding a less high ranking Consuela first
	--breadth first, would go through everything on one level first
	--secret to implementing a breadth first search is using a queue instead of a stack
	**Example:

1 class Node {
2    constructor(val, children=[]){
3        this.val = val
4        this.children = children
5    }
6    find(val){
7        const toVisitQueue = [this];
8        while(toVisitQueue.length){
9            const current = toVisitQueue.pop();
10            if(current.val === val){
11                return current;
12            }
13            for(let child of current.children){
14                toVisitQueue.push(child)
15            }
16        }
17    }
18 }
19
20 let htmlEl = new Node('html', [
21    new Node('head', [new Node('title')]), 
22    new Node('body', [new Node('ul', [new Node('li'), new Node('li2')])])
23 ]);
24
25 console.log(htmlEl.findBFS('li'))
	--the only real difference between this implementation and the DFS implementation is we remove things from stack/queue
	--in DFS, we are removing the most recently added thing from the stack
	--in BFS, we remove from beginning of our array (like a to do list)
		--so whatever is added first is worked on first
	**Visual Example:
		Queue: ['head', body']
		Current: ['head']
	Then
		Queue: ['body', 'title']
		Current: ['body']
	Then
		Queue: ['title', 'ul']
		Current: ['title']
	Then
		Queue: ['ul']
		Current: ['ul']
	Then
		Queue: ['li', 'li2']
		Current: ['li']
	--so in the visual above, whatever element we added first (so the element that's been in the stack the longest) is shifted to current
	--if that is not equal to the value we're looking for, then the children of that element are put into the queue
	--in the visual we see that head is pushed to current
	--since head is not the value we want, we move one
	--once we move on, body is shifted to the first element of the queue
	--then the children of body are added to the queue as well
	--the first element of the queue is again removed from the queue and pushed to current
	--so in our example, body becomes the current element and the next node is put into the queue



			11.13.7
			Tree Class
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64633

**So far we've been writing our code for trees directly inside the node class
	--so should we make a tree class or do we need one?
	--we don't NEED a tree class
	--we could keep track of the root which is useful
	--what gets confusing is that every node itself could be its own tree
**Let's see an example of making a tree class
	**Example:

class Tree {
    constructor(root){
        this.root = root
    }
    findInTreeDFS(val){

        return this.root.findDFS(val)
    }
    findInTreeBFS(val){

        return this.root.findBFS(val)
    }
}

const tree = new Tree(htmlEl)
	--here we have a way of "copying" a tree
	--this.root will refer to whatever root we copy
	--in the example, we copied htmlEl so the root of our new tree called 'tree' is the same
	--this.root.findDFS and this.root.findBFS are referencing our Node class from earlier
	--so now we can call tree.findInTreeDFS and it will do the same as htmlEl.findDFS
	--again that's because this.root.findDFS is referencing findDFS from our Node class




			11.13.8
			Trees Wrapup
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64635

**Let's talk about other types of trees
	--binary trees are trees that can have a max of 2 children on any particular node
	--if we structure binary tree we add left and right property
	**Why use a binary tree?
		--sometimes they're used to store data in a normal hierarchy, like a tree
		--they're often used for other structures
		--often they have a 'rule' about the arrangemenet:
			--binary search trees
			--min/max heap
	--we've also discussed quad-trees
		--these are often used for geographic programs, to keep track of N/S/E/W (cardinal directions) information from a node
**Advanced ideas about trees
	--there is not way to move up in a tree
	--in some trees, however, we can point up or down
		--this is called a bidirectionalNode or tree




			11.13.9
			Trees in Review
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64635

**Let's discuss the tree data structure

**Goals
	1.) Understand what a Tree Data Structure is.
	2.) Understand why we use Trees
	3.) Understand tree terminologies
	4.) Talk about Tree Nodes
	5.) Talk about types of trees
	6.) Learn how to traverse a tree
	7.) Go over applications of trees

**First up: Understand what a tree data structure is
	--trees are non-linear
**Second: Why do we need trees?
	--linear data structures store data elements in sequential form
	--in operation performed in the linear data structures, time complexity increases with increased data size
	--trees make storing and finding data less complex
	--tree data structure is non-linear and allows easier and quicker access to the data element
**Third: Tree terminology
	**Nodes: entity that contains keys and pointer to its child nodes
	**Edges: Connecting links of any two nodes
	**Root Node: in TDS (tree data structure) this is the very first node
	**Parent Node: in TDS, the node that is a node's predecessor
	**Child Node: the descendant node of any node
	**Leaf Node: node which does not have any children
	**Internal Node: node with at least one child node
	**Node Degree: the total number of children of a node
	**Example:

					A
			B				C
		D		E		F		G
	--in the tree above A, B, and C have a degree of two
	--this is because A has 2 children
	--the degree of B, D, and E is also 2 because B has 2 children
	--C, F, and G also have a degree of 2 because C has 2 children
	--D, E, F, and G have a degree of 0 because none of these nodes have children
**Tree Level: in a TDS, the root node is said to be at level 0 the children of the root node at level 1 and the children of nodes at 	level 1 will 	be at level 2

	**Example:

					A	(Level 0)
			B				C	(Level 1)
		D		E		F		G	(Level 2)
	--here we can see the levels of the tree with A at 0, B and C at 1 and D, E, F, G at 2

**Tree Height: the total number of edges from a leaf node to a particular node in the longest path
	**Example:

					A	(Height 2)
			B				C	(Height 1)
		D		E		F		G	(Height 0)
	--unlike levels, this calculated from the bottom up
	--so a is 2 "heights" above the very last level in the tree, meaning its Height 2
	--B and C are 1 "height" above the last level, so they are Height 1
	--D, E, F, G ARE the last level so they are Height 0

**Tree Depth: in TDS, the total number of edges from the root node to a particular node is called the depth of that node
	**Example:

					A	(Depth 0)
			B				C	(Depth 1)
		D		E		F		G	(Depth 2)
	--number of node edges connecting A to B and connecting A to C is one.
	--there are 2 edges connecting D, E, F and G to the root node

**Fourth: Talk about Tree Nodes
	--a TDS has a data part and references to it's left and right child node in the tree data structure
	**Example:

				Node
		Left Child 	Data	Right Child

*Fifth: Types of Trees
**There are four different types of trees
	1.) Binary Tree: each parent node at most has two children
	**Example:

						100
		50							150
			75					125
		74		76			124		130
	73									131

	2.) Binary Search Tree (BST): TDS in which each node has a max of two children
		--all nodes of the left subtree are less than the root node
		--all nodes of the right subtree are node than the root node
	**Example:

					40
		4							45
			34					55
		14					48		
	13		15			47		49					

	3.) AVL Tree: AVL tree got its name after inventory Georgy Adelson-Velsky and Landis
		--AVL tree is a self-balancing tree in whi8ch each node maintains a balance factor whose value is either -1, 0, or 1
		--Balance Factor: (Height of left subtree)-(heigh of right subtree) 
							or
				  (Heigh of right subtree) - (Height of left subtree)
	**Example:


			Insert 1
			5
		3		8
	1				12

	4.) B-Tree: Special kind of self-balancing search tree in which each node can contain more than one key and can have more than two children
		--B tree is also known as a height-balanced m-way tree.
**Sixth: Tree Traversal
	--this helpos to visit required node in the tree to perform specific operation
	--tree traversal can be performed in 3 ways
		1.) Pre-order Traversal: Visit Root Node. Visit all node from left side. Visit all nodes from right side
		2.) In-Order Traversal: First vist all nodes from left side, then root node, then all nodes from right side.
		3.) Post-order Traversal: Visit all nodes from left, then all nodes from right, then root node last

**Seventh: Applications of Trees
	1.) Binary Search Trees
		--quickly check whether an element is present in a set or not
	2.) B-Trees
		--most popular for databases
	3.) Tries (Modified version of trees)
		--used in the router to store rout8ing information
	4.) Syntax Trees
		--used by compilers to validate the syntax of every program you write



			11.13.11
			Binary Search Trees Handout
			https://lessons.springboard.com/Binary-Search-Trees-6caeb4153837418bb8bbcd5dc1133058

**Everything within this handout and more will be covered in the video curriculum




			11.13.12
			BST (Binary Search Trees) Intro
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64638

**BST
	--this is a slightly fancier version of a Binary Tree
	--it adds an additional layer of restraint to the 2 or less children rule

**Imagine we have list of words
	--apple, fence, ghost, jackal, just, money, mystic, nerd, pencil, zebra
	**Example:

[apple, fence, ghost, jackal, just, money, mystic, nerd, pencil, zebra]
	--we have an array
	--we know ways to search through this sorted array
	--time complexity of searching through this sorted array is O(log n)
	--inserting into this array is not going to be very efficient
	--we could find correct spot relatively easily because it's sorted
	--we could use binary search to find the correct spot to insert a new word (example: banana)
	--using an array to store sorted info works great if we just want to check for a value
	--adding new elements to the array, however, is NOT efficient
	--this is where a BST comes into play

**Binary Search Tree
	--if root node is money, then everything to the left of money is less than money
	--that's because it is alphabetically organized (A-L on left, money is root, N-Z on right)
	--this applies to every parent child combo (right is greater, left is lesser)
	--the whole advantage of a BST is that:
		1.) It is easy to find whatever value you are looking for
			--let's say we want to find the word ghost. We could eliminate the right side of the tree based on the letter g
		2.) It is way faster to insert something
			--we just have to find the appropriate place to put it

**Summary of this Type of BST (alphabetical arrangement)
	--a tree made of nodes
	--each node has a left and right child (or just left and just right, but at most left AND right)
	--has a "rule" for arrangement
		--makes it quick to search and insert data

**Another type of BST (arranged by greater or larger number)
							41
				20						65
			11		29			50			90
				12		32			53	72		99
					13
	--in this BST, everything to the left is less than the parent and everything to the right is greater than
	--this is the general concept of every BST
**BST are a very fast structure to add to and to search in



			11.13.13
			BST Class
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64640

**Implementing BST classes
	--Here's the tree we want to implement in JS
						E
				B				G
			C		D		F
	--now let's write it in JS
	**Example:

class Node {
    constructor (val, left=null, right =null){
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class BinarySearchTree {
    constructor (root){
        this.root = root;
    }
}

const E = new Node('E');
const A = new Node('A');
const B = new Node('B');
const C = new Node('C');
const D = new Node('D');
const F = new Node('F');
const G = new Node('G');

E.left = B;
E.right = G;
B.left = A;
B.right = D;
G.left = F;

const tree = new BinarySearchTree(E);



			11.13.14
			Searching A BST
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64640

**Let's add a method called find or search
	--this will allow us to pass in a value and find whether it's in the tree or not
	--we could use BFS or DFS, but that would defeat the purpose of a BST
	--so we will implement a much faster search method

**Let's look at this tree again

							41
				20						65
			11		29			50			90
				12		32			53	72		99
	--everything to the right of 41 is greater than 41
	--everything to the left is less than 41
	--so if we wanted to find the number 53, the first comparison we make is to the root node
	--since 53 is larger than 41, we can ignore the entire left side of this tree
	--that cuts the search time in half
	--we can go down the entire right side of the tree making similar comparisons
	--is 53 >, = or < 65
		--it's less than
		--is 53 >, = or < 50
		--it's >
		--now is 53 >, =, or < 53
		--it's =

**Now let's implement this search method
	**Example:

class Node {
    constructor (val, left=null, right =null){
        this.val = val;
        this.left = left;
        this.right = right;
    }

1.)   find (sought) {
2.)        let currentNode = this

3.)        while(currentNode){
4.)            if(currentNode.val === sought) return currentNode;
5.)            if(sought < currentNode.val){
6.)                currentNode = currentNode.left

7.)            } else {
8.)                currentNode = currentNode.right;
9.)            }
10.)        }
11.)    }
12.)}

	--let's walk through this code line by line
	--line 1 we're naming the method and saying that it excepts a value
	--the value it excepts will be what we are searching for within in the BST
	--line 2 we are setting the node that we are currently on equal to this
	--that will allow us to start wherever we would like within the tree so we don't have to start at root node
	--line 3 we use a while loop (so while there is a currentNode or while there is still something to search)
	--line 4 if the node we are currently on is equal to what we are searching for, we return that node
	--line 5 we make the comparison between what we're looking for and the currentNode
	--line 6 if the node we're currently on is bigger than the what we're looking for, we continue left
	--line 7 and 8 say that if our currentNode is smaller than what we want, we continue right
	--these lines of code will effectively let us search a BST for any given value

**Let's make it so we can see what node we are visiting throughout the search process
	**Example:

class Node {
    constructor (val, left=null, right =null){
        this.val = val;
        this.left = left;
        this.right = right;
    }

1.)   find (sought) {
2.)        let currentNode = this

3.)        while(currentNode){
4.)		console.log("Visiting:", currentNode.val)
5.)            if(currentNode.val === sought) return currentNode;
6.)            if(sought < currentNode.val){
7.)                currentNode = currentNode.left

8.)            } else {
9.)                currentNode = currentNode.right;
10.)            }
11.)        }
12.)    }
13.)}
	--this allows us to visualize the traversal of this BST




			11.13.15
			BST Search Runtime
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64640

**Runtime for BST Find
	--every time we make a choice (moving left or right) we cut potential choices in half
	--when we look at a small BST (like something with 20 or 30 nodes) this doesn't seem that significant
	--but when we look at a BST with thousands or millions or nodes, it is quite significant indeed

**What's the runtime of BST Find?
	--worst case scenario: for n nodes we search O(log n)
	--we can search >1000 nodes in only 10 steps
	--we can search >1,000,000 nodes in only 20 steps!!




			11.13.16
			Balancing a BST
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64640

**Valid Buy Badly Balanced BST
	**Example:

			B
		A		D
					E
						F
							G
	--can find A efficiently
	--can find missing C efficiently
	--can't find G efficiently
	--or if we wanted a letter greater than G we'd always have to look through that long side of the tree
	--tree needs to be "balanced"
	--for a tree to be considered balanced, we need to minimize the height of the tree
	**Example:

				E
		B				G
	A		D		F
	--this is the same  data as the tree above
	--the only difference is that it has been balanced

**Visualgo.net Example
	--we take a set of numbers: 20,23,24,26,25,28,30,90
	--this builds us BST, but this specific BST is much too tall for the amount of data that it's handling

**Balancing Trees
	--Easy ways to get reasonably balanced trees:
		1.) Shuffle values for tree randomly, and then insert
		2.) Sort values, then insert from the middle working out
	--we can see these methods at work using visualgo

**Self-Balancing Trees
--there are structure/algorithm pairs for BSTs that can balance themselves:
	1.) AVL Trees (AVL are the initials of the creators of this type of tree)
		--Keeps balanced. Simpler algorithm, but slightly less efficient
	2.) Red/Black Trees
		--Keeps "reasonably" balanced. More complex algorithm but can be more efficient
**How does an AVL Tree work?
	--if we take our original set of numbers 20,23,24,26,25,28,30,90 and create a BST, the tree will be lopsided
		--this is because of the order that we inserted the numbers into the BST
	--an AVL tree balances the data as the tree is created.
	--it inserts one piece of data, then another and balances the tree by picking a center
	--then it inserts another piece of data and balances it by picking a new center
	--it starts with the root node and its children
	--then it does the same thing with each subtree and its subsequent children
	--this goes on until the whole tree has been mapped out

**How does a Red/Black Tree
	--this method is preferred, even though we don't get a perfectly balanced tree
	--this is because we are more interested in efficiency than we are perfect balance in tree traversal
	--the term has to do with the way you determine if the tree is balanced or node
	--each node has an extra piece of storage that lets us know if it is Red or Black
	--by adding this tiny piece of info, we can follow a particular pattern
	--we can then use that piece of data and abide by a particular set of rules
		--a simple rule is if a node is red, its children will both be black
	--in other words, it's an additional constraint to keep the tree as short as possible




			11.13.17
			Traversing A BST
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64640

**What is Traversal?
	--often, you don't want to look at every node in a BST
	--that's the point -- you can search without looking at each
	--we don't use the logic of comparing left and right, because we can be more efficient than that

**Let's preview some traversal methods
	--these will involve recursion
	**Example:

	// In Order Traversal
1.) 	inOrderTraverse(node=this.root){
2.)        if(node.left) this.inOrderTraverse(node.left);
3.)        console.log(node.val)
4.)	   if(node.right) this.inOrderTraverse(node.right)
5.)	}
	--line 1 we are setting node to default to node.root
		--whatever root of tree is, when we call traverse we will start there
	--line 2 we start with the root and (if there is a left node) traversing the left side of the tree
	--line 3 we are printing the value of that root to the console
	--line 4 if there is a right node, we are traversing the right side of the tree
		**something to remember when traversing with this particular method
			--"traverse left, myself, traverse right" is "in-order"
	**Example:

					E
				B				G
			A		D		F
	--the way it would work here is we start with E, move to B, then to A 
	--A is the end so we go back to B ("traverse left" is now satisfied)
	--Going back to B satisfies "myself"
	--then we search the right side of B (now "traverse right" is also satisfied)
	--we then move back up to E and traverse the right side
	--that means we go from E to G, then to F then back to G
	--so we'd still be traversing left first on the right side of the tree
	--this is called In Order Traversal

**Example of Pre Order Traversal
	--fortunately all you have to do to change the order of the traversal is move the logic around
	**Example:

	 // Pre Order Traversal
1.)    preOrderTraverse(node=this.root){
2.)        console.log(node.val);
3.)        if(node.left) this.preOrderTraverse(node.left);
4.)        if (node.right) this.preOrderTraverse(node.right)
5.)	}
	--so this method is using the same logic, just in a different order
	--for this order type: "myself, traverse left, travers right" is "pre-order"
	**Example:

			E
	B				G
A		D		F
	--start with E (myself)
	--we move to B which becomes myself
	--then to A (which satisfies traverse left)
	--then we move back to B and on to D (which satisfies traverse right)
	--then we move back up to E (which is again myself)
	--then down to G which become myself
	--then to F which fulfills traverse left
	--then back to G and since there is no right node, this fulfills traverse right as well

**Example of Post Order Traversal
	**Example:

	 // Post Order Traversal
1.)        postOrderTraverse(node=this.root){
2.)        	if(node.left) this.postOrderTraverse(node.left);
3.)             if (node.right) this.postOrderTraverse(node.right)
4.)        	console.log(node.val);
5.)	}
	--again, we are using the same logic as Pre Order and In Order Traversal methods
	--the only difference is the order that the logic is executed in
	--for this order type: "traverse left, travers right, myself" is "post-order"
	**Example:

			E
	B				G
A		D		F
	--from E we go all the way to the left (which is A in this case)
	--A is myself and printed to the console
	--then we go back to B and down to D (D is printed to console)
	--then back to B and B is printed
	--then we go up to E and all the way down to F (F is printed)
	--then we go to G, which is printed
	--then we end at E, which is also printed
	--basically we go all the down the left side of the left side as far as we can and work our way back up
	--then we go all the way down the right side of the left side and work our way back up
	--then we go to right side and go all the way down the left side of the right side and work our way up
	--and finally we go all the way down the right side of the right side and work our way back up





			11.13.18
			Binary Search Trees Review
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64628/64647

**Agenda for BST Review
	1.) What is Binary Tree
	2.) Terms related to Binary Trees
	3.) Implementation of Binary Trees
	4.) Properties of Binary Trees
	5.) Types of Binary Trees
	6.) Operations for Binary Trees
	7.) Key Take-Aways

1.) What is a Binary Tree?
	--a tree where each node can have AT MOST 2 child nodes
	--these are called left and right children

2.) Terms related to Binary Trees
	a.) Node: data that points to a left and right child
	b.) Root: first node of the tree
	c.) Leaf Nodes: nodes without chidren
	d.) Parent Node: any node with at least one child
	e.) Child Node: any node with a parent
	f.) Internal node: a node with a child node AND a parent node
	g.) Height: longest path from root to any leaf node
	h.) Depth: total number of edges from root to last child node

3.) Implementation of Binary Trees

4.) Properties of Binary Trees
	--maximum number of nodes at level L=2^L
	--max number of nodes in a binary tree of heigh H=2^H - 1
	--minimum possible height in a Binary Tree with N nodes = log2(L+1)
	--min possible level in a Binary Tree with N nodes = log2(L + 1)
	--a binary tree with L leaves has at least |log2L| + 1 Levels

5.) Types of Binary Trees
	a.) Full Binary Tree
		--nodes can have 2 children or no children
	b.) Complete Binary Tree
		--each node has to have 2 children, except in the last level
	c.) Perfect Binary Tree
		--every node has 2 children and every leaf is on the same level
	d.) Balance Binary Tree
		--when height of left and right subtrees varies at most by 1
	e.) Degenerate Binary Tree
		--if every internal node has only 1 child

6.) Operations of a Binary Tree
	a.) Traversal
		*Pre-order
		**In-order
		**Post-order
	b.) Insertion
	c.) Deletion

A.) Binary Tree Traversal (see notes from 11.13.17)
	*Pre-order
	**In-order
	**Post-order

B.) Insertion (refer to notes from 11.13.12)
C.) Deletion (refer to notes from 11.13.12)

7.) Final Takeaways Regarding Binary Trees
	--faster at search operations than other types of trees
	--easier to find max and min element
	--Binary Tree doesn't allow duplicate values
	--graph traversal is done using binary tree
	--used to convert postfix expressions in prefix expressions




			EXTRA NOTES
			BST Iterative Insert Method
			https://www.youtube.com/watch?v=dVSxO83aseU

**Here's what we're going to create

					20
			10				30
		5		15		25		32
	--this is a simple BT

**Now let's implement this tree using JS
	**Example:

// this will consit of root node and methods we want to use
class BST{

    //constructor will be run whenever we create a new instance of the BST
    constructor(){
        this.root = null        // this means the root won't have a value until we assign it one
     }
}

// this will be used to create the nodes of the tree
class Node{

    //this constructor will consist of the 3 things
    constructor(value){
        this.value = value

        // like this.root = null. this means the left/right nodes don't have a value until we assign them one
        this.left = null        
        this.right = null
    }
}
// this is how we assign a value to the root
const tree = new BST()
tree.root = new Node(20)
console.log(tree)
	--this is the skeleton of creating a BST
	--we started by creating the BST class which defines the root node of the tree
	--then we created the Node class, which allows us to define additional nodes
	--the manual way to insert roots looks like the following
	**Example:

// Create the tree and root node
const tree = new BST();
tree.root = new Node(20);

// Manually add child nodes
tree.root.left = new Node(10);   // 10 is less than 20, goes to the left
tree.root.right = new Node(30);  // 30 is greater than 20, goes to the right

// Add more nodes to the left subtree
tree.root.left.left = new Node(5);   // 5 is less than 10
tree.root.left.right = new Node(15); // 15 is greater than 10

// Add more nodes to the right subtree
tree.root.right.right = new Node(40); // 40 is greater than 30
	--it is obvious that the manual way to add nodes to a BST is tedious and arduous
	--that's why we use the insert method

**Writing the Insert Method
	--when inserting nodes to a BST we need to ask some specific questions.
	1.) Is the data I want to insert (numbers for our purposes) > or < our current node
		--currently we have 20 as our root node
		--if we want to insert 10 we ask "is 10 > or < 20.
		--if it's less than, it goes to the left
		--if it's greater than, it goes to the right
		--so that's the way we need write our logic
		--now let's say we also want to insert 5
	2.) Is there currently something as a left or right child node?
		--if there were already a left child, we would have to move the current node to the next node without a left child
		--let's say we want to insert the number 5 after we've already inserted 10
		--5 is < 20 so it goes to the left
		--since 10 is already the left child of 20, we have to move our "current marker" to 10
		--then we ask the first question again
		--since 5 is < 10, we place 5 as the left child of 10
	**Example:
		--now we want to insert the number 15
		--our current marker is on 10
		--we ask the first question "Is 15 > or < the current node (10 in this case)
		--we find that 15 is > 10
		--so we insert 15 as the right child of 10
	**Example:
		--now we want to insert the number 2
		--our current marker is still on 10
		--we ask the question "Is 2 > or < 10?"
		--it is <, but 10 already has a left child
		--that means we move our current marker to the left child of 10 (5 in this case)
		--then we ask the question "Is 2 > or < 5?"
		--it is < and since 5 does NOT have a left child, we insert 2 as its left child
	--this is the concept of the insert method within a BST




			MORE EXTRA NOTES
			BST Find Method
			https://www.youtube.com/watch?v=9dvA1etTUfc

**Below are notes alongside the code for creating a find method

     find(value){

        // if there is no root, there is no tree to traverse and the value we are looking for is not present.
        if(!this.root){
            return false    
        }

        // this allows us to traverse the tree without changing the root node. 
        let tree = this.root;

        while(tree) {

            // this if statement determines if the value we're looking for is < the value we're pointing at. If it is, we move down the tree to the left
            if(value < tree.value){
                tree = tree.left
            
            // determines if value we're looking for is > value we're pointing at. if so, we move down the tree to the right.
            } else if(value > tree.value){
                tree = tree.right
            
            // determines if value we're looking for is = to value we're pointing at. if so, we return the tree.
            } else if(value === tree.value){
                return tree;
            } 
        }

        //this will initialize if the tree value becomes null. this will also end the while loop.
        return false
     }
	--there you have it! the find method that can be used to lookup something in a BST




			




















