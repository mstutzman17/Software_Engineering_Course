Notes for Unit 11 Subunit 9

			11.9.1
			rest/spread Handout
			https://lessons.springboard.com/Rest-Spread-Operator-ce38fb9134904e0f9610d45863d7dbaf

**The link above is for a text document that explains what's coming up in Subunit 9
**The Goals are of this Subunit are:
	1.) Understand what the rest operator does
	2.) Understand what the spread operator does
	3.) Use spread to copy arrays and objects
	4.) Use rest to gather remaining arguments in an array

			11.9.2
			The arguments Object
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560

**Rest and Spread
	--operators in JS
	--they use the same character, but operate differently
	**Example:

1 + 4		'a' + 't'
	--the same concept is being used in both examples, but the outcome is different
	--it's the same with rest and spread

**Syntax for rest and spread
	--the syntax is ...
	**Examples:

function min(...nums){
    
}
	--spread/rest as a parameter

[...]
{...}
	--spread/rest in arrays and objects
	--sometimes it's called rest and sometimes it's called spread

**Goals Overview
	1.) Understand what the rest operator does
	2.) Understand what the spread operator does
	3.) Use spread to copy arrays and objects
	4.) Use rest to gather remaining arguments into an array

**We'll start with rest and how things used to be
**So what was life like before rest?
	--The arguments object
	--sometimes we have unlimited arguments passed in
	--there are built in JS methods 
	--like Math.max
	**Example:

Math.max(1,4,6,99)
	--this would give us the highest number in any given set of numbers
	--how would we write a function for this without using the .max method?
	--something that will accept any number of arguments
	--it's not easy without an arguments object
	**Example:

function max(a , b , c , d , e , f , g){
    
}
	--this way of doing it would be very messy, because we would have to reference every letter throughout the function
	--this is not how Math.max is written
	--we don't have to account for a variable list of arguments
	--instead we don't have to write anything in the list of parameters
	
**Still what we used to do
	--In JS, every function created using the function keyword has access to a special keyword called arguments
	--except arrow functions

**Let's look at arguments
	**Example:

function max(){
    console.log(arguments);
}
	--if just pass in arguments to the console, we'll get a ReferenceError: arguments is not defined.
	--that's because arguments is not valid outside of a function
	--but if we call the function, arguments will be an object
	**Example:

console.log(max())
	--if we call max() with a parameters we will get the same object with new information
	**Example:

console.log(max(2,5,4,78,17))
	--return here is Arguments(5) [2,5,4,78,17]
	--this could be very useful to use
	--let's look at another example using sum
	**Example:

function SubmitEvent() {
    arguments.reduce((sum, val)) => {
        return sum + val;
    }
}
	--now if we try to call this function we will get "Uncaught TypeError: argumetns.reduce is not a function
	--that is because arguments LOOKS like an array but IS NOT an array
	--arguments is an 'array-like'object'
	--so it is an object not an array
	--still, arguments has a length property
	--still, you can access it at a specific index
	**Example:


function sum() {
    console.log(arguments[0])
    arguments.reduce((sum, val) => {
        return sum + val;
    })
}
	--HOWEVER, it doesn't have built in array methods like map, filter, etc.
**In the Past
	--we would make the arguments object into an array
	**Example:

function sum() {
    console.log(Array.from(arguments))
    arguments.reduce((sum, val) => {
        return sum + val;
    })
}
	--now sum(3,4,5) would return the array [3,4,5]
	--arguments.reduce would still not work
	--we could store Array.from in a variable and retrun it
	**Example:

function sum() {
    const args = Array.from(arguments)
    return args.reduce((sum, val) => {
        return sum + val;
    })
}
	--this would make our function work like it's supposed to
	--now the a sum of whatever array is passed in will be returned
	--the above example, although refined, is still not as easy as it could be.

**Another shortcoming of the argrumnets object
	--they don't work AT ALL in arrow functions
	**Example:

const max = () => {
    console.log(arguments);
}
	--if we tried to call the max function we would get an "Uncaught ReferenceError: arguments is not defined at max"
	--if we just tried calling arguments, we would get "arguments is not defined"
	--that's because arguments do not exist in arrow functions (AF)
	--we still have a way of working with unlimited or variable arguments inside arrow functions
	--we just can't use it in AFs

**Let's try writing max as a regular function expression
	**Example: 

const max = function() {
    const args = Array.from(arguments);
    return args.reduce((max, currVal) => {
        return currVal > max ? currVal : max;
    });
};
	--this is the old way of how we could handle functions with unlimited or variable arguments

			11.9.3
			The rest Operator
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560

**Rest is the new way of doing the same thing as arguments do
	--it also works is AFs

**AGAIN
	--rest/spread use the same syntax (...)
	--when the three dots are part of a function definition, we call the operator the 'rest' operator
	--so inside a function parameter list
	--the rest operator is the last parameter defined in a function and will evaluate to an array of all additional arguments passed in
	**Example:

function sum(...nums){
   console.log(nums)
}
	--if we call sums with any given set of numbers, it will return an ACTUAL array
	--we don't have to convert it to an array and then use array methods
	--it's an array right out of the gate
	**Example:

function sum(...nums){
    return nums.reduce((sum, n) => sum + n);
 }
	--the rest operator also works with AFs and implicit returns
	**Example:

const sumAll = (...values) => {
    return values.reduce((sum, n) => sum + n );
}
	--this is the first use case for rest
	--we can collect all arguments that are passed in

**The rest operator is the last parameter defined in a function and will evaluate to an array of all additional arguments passed in
	--so we can use rest to collect remaining arguments
	--we can start with named parameters that will capture on their own
	--this is where the rest name comes from (it collects the rest)
	**Example:
--we want an array that will make a family array with 2 parents and subsequent children

function makeFamily(parent1, parent2, ...kids){
    console.log(parent1, parent2);
    console.log(kids);
}
console.log(makeFamily("Moses", "Barbara", "Warren", "Evelyn")
	--this will return an array with ["Moses", "Barbara"]
	--there will be another array with 0: Warren and 1: Evelyn
	--if we did not add the children, the children array would still exist, it would just be empty
	--now let's update makeFamily so that it returns an object
	--we will set parents to an array with 2 items
	--and we set children to an array if there are kids in the array
	**Example:

function makeFamily(parent1, parent2, ...kids){
    return {
        parents: [parent1, parent2],
        children: kids.length ? kids : "None"
    };
}
console.log(makeFamily("Moses", "Barbara", "Warren", "Evelyn")
	--now we will get an object with 2 arrays.
	--the first array will be called children and contain the kids names
	--the second array will be called parents and contain the parents names
	--if we didn't add children so we did console.log(makeFamily("Moses", "Barbara")
	--we would get the parents array and children would be labeled "None"
**Let's try another example
	--we want to filter by type
	--so we could pass in a string as first argument and then pass in some value
	--that would return an array that filters out the strings and puts them into an array
	--if we filter by type Boolean it should contain an array that says true
	--and so on and so forth
	**Example:

const filterByType = (type, ...vals) => {
    return vals.filter(v => typeof v === type)	// for each val (v) the callback === the type passed in
}
console.log(filterByType('string', 23,45,true,false, 0, 'hello', 'goodbye'))
	--this would return an array with 2 items
	--the items would be the 2 strings in the argument 'hello', 'goodbye'
	--we could do the same thing and filter for number
	--console.log(filterByType('number', 23,45,true,false, 0, 'hello', 'goodbye'))
	--this would return an array with 3 items
	--the 3 items would be the three numbers within the argument
	--23, 45, 0

**There's one GOTCHA
	--if you try to use rest when it's not the last parameter it won't be fun
	**Example:

function printStuff(a,...rest,b)
	--this will not work because JS expects a closing parens because the rule is for rest to be the last parameter
	--if we run this code we would get an "Uncaught SyntaxError: Rest parameter must be last formal parameter"
	--because rest collects the "rest" of the arguments, if it's not the last formal parameter, it will not work

			11.9.3
			spread Function Calls
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560


**Spread Operator
	--unlike rest, we can use spread in multiple situations
	--rest is only used when defining function expressions
	--we can use spread in function calls, arrays, and objects
	--the ... syntax, in a different context, is called the spread operator
	--for example: when calling a function, you can 'spread out' array elements
	**Example:

function takesFour(one, two, three, four) {
    console.log(one);
    console.log(two);
    console.log(three);
    console.log(four);
}

const names = ['Mary', 'Colt', 'Angela', 'Abe',]

takesFour(...names)
	--if we have an array of names and want to call takesFour and pass in those names, we would get one array
	--two, three, and four would be undefined
	--that's because we'd only be passing one argument, which will be handled by the 'one' argument
	--however, if we use the spread operator it will spread out the array into individual arguments
	**Another Example:
**We want to use Math.max with an array of numbers so we make a variable with an array
const nums = [4,5,88,123,0,92]
	--to find max of the entire nums array we pass one argument in
Math.max(nums)
	--this will return NaN (not a number)
	--that's because instead of trying to find the maximum of the numbers within the array this will try to find the max of the whole array and nothing 	else
	--so we're comparing one item (an array with multiple elements as one item) to another (nothing as an nothing)
	--that's not what we want
	--we want to pass in the numbers individually
	--that's where the spread operator comes in
	**Example:

Math.max(...nums)
	--you can think of it as looping
	--it takes each element and adds them as individual arguments
	--and from that the Math.max method is applied
	--this will then do what we want it to and return the largest number within any given set of numbers

**More examples and learning
	--recall the filterByType function from another lesson
	**Example:	

const filterByType = (type, ...vals) => {
    return vals.filter(v => typeof v === type)
}
filterByType('string', 23,45,true,false, 0, 'hello', 'goodbye')
	--let's put the arguments into an array of their own and make it a variable

const things = ['string', 23,45,true,false, 0, 'hello', 'goodbye']
	--we want to get a new array containing the strings
	--so we call filterByType(strings)
	--then if we pass in things (filterByType(strings, things) it won't do what we want
	--if we look at what things would be it's an empty array
	--that's because again JS is taking the whole array and seeing it as one thing
	--we want JS to see the array and each element inside it
	--that's why we use spread
	**Example:

console.log(filterByType('string',...things))
	--this will give us an array with 2 elements, like we wanted
	--this shows we can spread not only the only argument in a function
	--we can also spread after arguments (like the filterByType example)

**We're not limited to spreading exclusively arrays
	--we can spread other iterables (something we can iterate over)
	--another type of iterable is a string
	--we know if do console.log(2,3,4,5,6) it would print as 2 3 4 5 6
	--if we try to log 'things' it will print out the whole 'things' array as an array
	--if we spread 'things' into the console.log it will print each element of the array as an argument
	--and the elements will no longer be inside the array
**Let's see an example
	--we'll do the same thing with a string
	**Example:

console.log(...'HELLO')
	--this will print H E L L O to the console
	--in effect we are doing the following
	-- console.log('H', 'E', 'L', 'L', 'O')
	--but takes half the time and effort
**SOOOOOOO.....
	--when you spread an array it iterates over each element and pulls it out as individual arguments
	--when you spread a string it iterates over each letter in the string and pull them out as individual letters

			11.9.5
			Spreading Arrays
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560

**We've seen how we can use spread in function calls
	--so we can spread iterables as singlular arguments

**Now we will talk about how we can spread over array literals
	--so we know that when we see square brackets ([]) we are creating a new array
	-- const palette = ['lavender berry', 'sunflower yellow', 'orchid orange']
	-- we can spread an iterable into the above array
	**Example:

const ['lavender berry', 'sunflower yellow', 'orchid orange']
	--we want to copy this array several times, but don't want to type out the array every time
	--there are several ways to do this
	--first, one way NOT to do it
	**Example:

const paletteCopy = palette
	--this will NOT make a copy of the palette array
	--arrays are reference types so paletteCopy has the exact same reference as palette
	--let's prove it with an example
	**Example:

paletteCopy.pop()
	--so we want to remove the last element of the paletteCopy array
	--if we check, the last element has been removed from paletteCopy
	--the problem is that the last element of the palette array has also been removed
	--so we did not make a copy, only made two things pointing to the same reference

**What if we wanted to make copy without spread?
	--one option is to array.slice (palette.slice)
	**Example:

palette.slice(2)
	--this will create a new array from index 2
	--if we don't pass in an argument, however, it will create a new array with the same elements as the original
	**Example:

const paletteCopy = palette.slice();
	--so here paletteCopy is pointing to a different space in memory
	--if we change palette or we change paletteCopy the changes will only apply to the one we specify
	--this still doesn't involve spread
	--we can use spread to accomplish the same thing however
	**Example:

const palette = ['lavender berry', 'sunflower yellow', 'orchid orange']
const paletteCopy = [...palette]
	--this does the same thing as we was accomplished above
	--this takes the original array and spreads into pieces then places them into an empty array
	--if we compare palette ==== paletteCopy we get false
	--they are not the same thing and paletteCopy is an actual copy of palette

**Where does spread and array literals become extra useful?
	--we can combine arrays
	--we can add on to arrays by passing in new arguments after we spread
		--it would be like pushing something to the end of an existing array
	--we can even add arguments before we spread.
	**Example:

const paletteCopy = ['sky blue',...palette, 'grass green']
	--so now we would have a new color at the start of the array and at the end (before and after the spread)
	--at the same time, the original palette variable remains unchanged
	--this happens because once we spread palette and saved into the paletteCopy variable, we changed where each variable is pointing in memory

**We can also spread multiple times
	--let's say we're making a website for a coffee shop
	--we want to have a couple categories
	--if we wanted to create a new array creating all the different teas we have, we could use spread to help us do it
	**Example:

const greenTeas = ['snow jasmine', 'fragrant leaf']
const oolongTeas = ['oney orchid', 'winter sprout']
const herbalTeas = ['afrincan solstice', 'marshmallowroot']
const coffees = ['gutemala red cat', 'snow leopard blend']

const allTeas = [...greenTeas, ...oolongTeas, ...herbalTeas]
	--to start we have 3 arrays with names of different teas and one with names of different coffees
	--we quickly and efficiently created an array called allTeas and combined all three tea arrays in one
	--we did this by spreading each array into an empty array and saving it as a constant variable called allTeas
	--none of the original arrays were changed in any way
	--we can do it again and add an element that is not in the array as well
	**Example:

const withCaffeine = [...greenTeas, ...oolongTeas, ...coffees, 'Earl Grey']
console.log(withCaffeine)
	--now we have a new array, with different elements from the original arrays and one new element that we added in the same line of code

**Similar to when we spread arrays into function calls, we can spread into an array literal
	--we can spread other iterables like strings
	**Example:

const vowels = 'aeiou';
const vowelArr = [...vowels]
	--this creates an array with all the vowels as individual elements in the same array
	--we could also do something like the following
const vowelArr = [...vowels, 'sometimes y']
	--this would spread the vowels into a new array and add 'sometimes y' at the end
	
**Review
	--spread is a great way to:
	1.) Create copies of an array
	2.) Combing multiple arrays
	3.) Creating new arrays based on existing arrays without having to use a bunch of different methods

			11.9.6
			Spreading Objects
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64565

**Can we spread an object into an array or a function call?
	--let's find out
	**Example:

const tea = {
    type: 'oolong',
    name: 'winter sprout',
    origin: 'taiwan'
};

const arr = [...tea];
	--we are attempting to spread an object into an array
	--this WILL NOT work, however, because objects are not iterable and arrays are
	--the same is true for the following example
	**Example:

for (let x of tea) {
    console.log(x);
}
	--tea is not iterable
	
**We can use spread inside of a new object literal
	--it is the same principle, but behaves differently with objects than arrays
	--you can use the same operator to copy over pieces of an object into a new object
	**Example:

for (let x of tea) {
    console.log(x);
}

const tea2 = {...tea};
	--just like when we copy an array, we are copying the object
	--the object we spread has the same properties as the original object
	--the difference is that each object is pointing to a different location in memory

**We can also add and change properties similar to how we could with arrays
	**Example:

const tea = {
    type: 'oolong',
    name: 'winter sprout',
    origin: 'taiwan'
};
	
const teaTin = {...tea, price: 22.99 };
	--here we are spreading tea into a new object literal and adding a property to that new object literal
	--order matters when we spread objects if we have confliciting properties
	**Example:

const tea = {
    type: 'oolong',
    name: 'winter sprout',
    origin: 'taiwan'
};

const newTea = {...tea, name: 'golden frost'}
	--in this example, because there is already a name property, we have changed it from 'winter sprout' to 'golden frost'
	--but what if we tried setting the name before we spread the object?
	**Example:

const tea = {
    type: 'oolong',
    name: 'winter sprout',
    origin: 'taiwan'
};

const newTea = {name: 'golden frost', ...tea}
	--what happens here is the name is changed, but then when tea is spread that name change is overridden
	--so it appears that the name did not change when, in reality, it was changed and than changed back

**We can also use spread to combine an object into a new object
	**Example:

const tea = {
    type: 'oolong',
    name: 'winter sprout',
    origin: 'taiwan'
};

const teaData = {
    steepTime: '30s',
    brewTemp: 175
}

const fullTea = {...tea, ...teaData}
	--if we look at full tea it has all of the properties from both objects
	--now let's say we have a conflict of properties
	--both objects have a property of origin
	--in the tea variable it's Taiwan and in the teaData variable it's Japan
	--which property will show in the new object?
	--spoiler alert, it's Japan
	--the reason it's Japan is because teaData was spread second
	
**What happens if you try to spread an array into an object?
	--it can get confusing
	**Example:

const colors = ['red', 'orange', 'blue']
const dummyObj = {...colors}
	--so here we are spreading an array into an object
	--what happens is JS takes the indices of the colors array and changes them to key pairs in the new object
		0: 'red'
		1: 'orange'
		2: 'blue'
	--this is because in JS arrays are just special types of objects with additional methods and functionality

**What if we spread a string into an object?
	--what do we think would happen?
	**Example

const dummyObj = {...colors, ...'purple'}
	--here we are spreading the colors array and the string 'purple' into an object 
	--what happens is the word purple is placed inside the new object in the same way the colors array was
	--that is, the new object contains a key pair for each letter in the string
		0: 'p'
		1: 'u'
		2: 'r'
		3: 'p'
		4: 'l'
		5: 'e'
	--but what happened to the colors array?
	--strings are primitive values but JS makes a temporary wrapper object for each string
	--that means the string 'purple' is considered an object and iterable
	--so what is happening is the objects are confliciting
	--the colors object is created, and then it is overridden by the string 'purple'
	--we can prove this by changing the order that we spread the string and the array
	**Example:

const dummyObj = {...'purple', ...colors}
	--what actually happens here is the new object contains 6 key pairs
	--the first 3 are the colors array and second three are the last 3 letters of the string 'purple'
	--so it seems that if you spread a string first, the length of that string determines how many key pairs are in the new object

**Review: we've seen spread in 3 different ways
	1.) Using it to call a function to spread an iterable into separate arguments 
	2.) Using it inside array literal to copy/combine arrays to a new destination
	3.) Using it inside object literals to copy/combine arrays to a new destination

			11.9.7
			Spread and Deep Copies
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64565

**Let's talk about cloning or creating copies of nested data structures using spread operator
	--spread is great to create copies of shallow data structures (one level array or object)
	--when we use spread it won't create a deep copy/clone
	--Example:

const shoppingCart = [
    {
        name: 'honey orchid',
        quantity: 2,
        price: 13.50
    },
    {
        name: 'african solstice',
        quantity: 4,
        price: 25.99
    }
];

const cartCopy = [...shoppingCart]
	--what happens here is what you would expect
	--when we spread shoppingCart into the new array we get 2 arrays with one object in each
	--the objects have all the key pairs you would expect
	--and if we compare cartCopy === shoppingCart it would return false
	--that means it has created a true copy
	--HOWEVER!! If we compare cartCopy[0] === shoppingCart[0] we get true!
	--that means that both cartCopy[0] AND shoppingCart[0] are pointing at the same reference in memory!

**If we update the quantity for the honey orchid in the cartCopy array (the new array) what would happen?
	--let's see
	**Example:

cartCopy[0].quantity = 99;
	--here we have updated cartCopy
	--the sad part is we also updated shoppingCart
	--this is because spread can allow make shallow copies, one level deep
	--if we try to make a copy of nested objects or arrays, it will only duplicate it
	--so spread CANNOT make deep clones where every level of nested code is copied
	--BOOOOOOOOO

			11.9.9
			Object Enhancements Handout
			https://lessons.springboard.com/Object-Enhancements-bdaac698087c4bd39cbdce07b82e6843

**This handout contains a text document for the information that we will be covering in detail in the upcoming Video Curriculum.
**These things include the following:
	1.) Object Shorthand
	2.) Object Methods
	3.) Computed Property Names
	4.) Current Usage
	5.) Computed Property Names in the Wild

			11.9.10
			Property Names Shorthand 
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64565

**Three small features to create object literals
	1.) Object Property Shorthand
	
**It's common to create objects
	--like inside a function
	--we had an old way of doing this
	**Example: 

function makePerson (first, last, age){
    return {
        first: first,
        last: last,
        age: age,
        isAlive: true
    };
}

console.log(makePerson ('Moses', 'Stutzman', 32))
	--the function above accepts 3 parameters
	--when it's called you pass in arguments, it returns an object with all 4 arguments.
	--we connected to the parameters of the function to the properties of the object that is being created
	--then we console.log it voila, we have an object with all the properties we set
**What is mildly annoying about this "old" way of doing what we just did?
	--we have to type first, last and age twice when we're setting the properties for the object
	--there is a new shorthand option
		--if we want to create a new object with properties based off an existing variable
		--AND we want to use the name of that variable as the key in the object
	--what we can do for this shorthand is remove the what we want the key name to be and what it's referencing
	--(Ex. first: first becomes just first; last: last, becomes just last,)
	--ES6 JS is now built to understand that we want to use the parameters of the function as keys for the object we're creating.
	**Example:

function makePerson (first, last, age){
    return {
        first,
        last,
        age,
        isAlive: true
    };
}

console.log(makePerson ('Moses', 'Stutzman', 32))
	--the code above works the same way as the "longhand" we started with
	--we don't have to duplicate the property name AND the variable name
**Browser support
	--MDN object initializer page
	--we have support in all major browsers except Internet Explorer (IE)
	--we can use babel again to transpile this shorthand to something that would work in IE

			11.9.11
			Methods Shorthand
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64565

**New small features to create object literals in JS
	1.) Object Property Shorthand
		--we discussed this in Subunit 10
	2.) Creating methods easier in an object

**Review
	--created methods are functions inside an object that we are storing as a property of that object
	**Example:

const mathStuff = {
    x: 200,
    add: function (a,b) {
        return a + b;
    },
    square: function (a) {
        return a * a;
    }
};

console.log (mathStuff.add(17,17))
console.log (mathStuff.square(17,17))
	--so here we have used the add methods that we created as properties inside of the object called mathStuff
	--and that's what created methods look like inside an object
**There is a new shorthand way to do what we just did
	--this is used when a key in an object represents a function
	--this allows us not to use the colon syntax
	--instead we can write functions like the following
	**Example:

const mathStuff = {
   x: 200,
   add(a,b){
    return a + b
   },
   square(a){
    return a * a;
   }
};
	--in the shorthand to create an object method we did 2 thigns
		1.) Remove the word function before the parameters of our function
		2.) Remove the colon after the method/key name
		**Ex: add: function() becomes just add()
		**Ex: square: function() becomes just square()
**IMPORTANT NOTES: 
	1.) When using this syntax it's easy to forget that it is as a regular property
		--thus it's easy to forget a comma after we specify what a method is doing
		--DON'T FORGET THE COMMA!
	2.) DO NOT use arrow functions here!
		--What would happen if we try to use an arrow function?
	**Example: If we tried to add an arrow function

square(a) => {
  return a * a;
 }	
	--JS doesn't like this because it's expecting a curly brace after square(a)
	--If tried adding an AF like we normally do what would happen?
	**Example:

() => {
    
}
	--this wouldn't work becuase there is no property name
	--Unlike function definitions AFs are not named
	--you coulnd't randomly through an AF in your code like, but you can do that with a function definition
	--you can't use AFs with this shorthand
**If we REALLY wanted to use an AF to create an object method we could do something like the following
	**Example:

multiply: (a,b) => {
return a * b;
}
	--this would work
	--but again, we CANNOT use an AF for the shorthand to create objects methods

**Again we can through this shorthand into Babel
	--IE doesn't support the Methods shorthand
	--babel can transpile code for this JS feature into code that would work on all browsers (including IE)


			11.9.12
			Computed Property Names Shorthand
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64572

**New small features to create object literals in JS
	1.) Object Property Shorthand
		--we discussed this in Subunit 10
	2.) Creating methods easier in an object
		--we discussed this in Subunit 11
	3.) Computed Property Names

**Computed Property Names
	--ES2015 allows us to create and object with a key that JS can compute at definition
	--concise way of adding key to object where key name is variable/dynamic
	--not a hard coded thing, so it could be different everytime
	--consider two color names and hex codes
	1.) 'periwinkle' '9c88ff'
	2.) 'bright ube' 'D6A2E8'
		--we want to make an object to look up hex code based off color name or color name based off hex code
	--the following is how we would hard code it
	**Example:

const color = {
   periwinkle: '9c88ff',
   '9c88ff': 'periwinkle'
};
	--this would achieve what we want
	--now we want to create a function with "two way lookup"
	**Example:

function makeColor(name, hex) {
   return {
      name: hex,
      hex: name
   };
}
	--now if pass in a color name and hex code we get an object with hex and name as keys.
	--the values of those keys are defined by the arguments we pass in when calling the function
	--what we want to do is make the key for name the actual name of the color and the key for the hex code the actual hex code for the named color
	--we want to the key names to be dynamic
	--in the past (without the enhancement of computed properties) is the following
	**Example:

function makeColor(name, hex) {
   const color = {}; // variable called color with empty object
   color[name] = hex;   // square brackets evaluate the value of name and hex and return a string
   color[hex] = name;
   return color;
}
	--so here we had to make an object as one step and add each dynamic property as a separate line
	--if wanted to make a single expression to add everything at once and return at the same time, we use computed property names
	**Example:

function makeColor(name, hex) {
   return {
      [name]: hex,
      [hex]: name,
   }
}
	--this does the same as the previous example, with less characters and less steps
	--we could add multiple dynamic properties
	--we can also add regular properties within the same object
	--we could also write code within the square brackets
	**Example:

const mystery = {			const obj = {};
   [6 + 7]: 'thirteen'			obj [6 + 7] = 'thirteen'
};
	--both sets of code do the same thing
	--the differences is that the first block is shorthand for dynamic properties

**Browser Support
	--IE does not support this shorthand
	--again we could use babel to transpile the shorthand to code that would work in IE and other non supported browsers

			11.9.13
			Array and Object Destructuring Handout
			https://lessons.springboard.com/Array-and-Object-Destructuring-9a11404c374e416296d9337795f93b80#4fc5d771e3a446519a5814bfd43a37ff

**This handout list some goals for the next concepts
	1.) Understand what Destructuring is
	2.) Use object Destructuring to write less code
	3.) Use array Destructuring to swap values and extract nested values

**There is also text and examples for the following topics/concepts
	--Object Destructuring
	--Destructuring and Spread
	--Renaming with Destructuring
	--Defaults with Destructuring
	--Destructuring Nested Objects
	--Destructuring Functions
	--Applying the same Concept to Arrays
	--Fancy 1-Line Array Value Swap

			11.9.14
			Object Destructuring
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64574

**Goals for Destructuring
	1.) Understand what Destructuring is
	2.) Use object destructuring to write less code
	3.) Use array destructuring to swap values and extract nested values
	4.) Use destructuring in function definitions
**What is destructuring?
	--when you have data structure with different values we can destructure those values
	--think of it as extraction: we can extract certain values into new variables with simple syntax
	--let's start with an object called teaOrder with 6 properties
	**Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};
	--let's try to alter this object without destructuring
	--we want to get the value of origin in new variable and extract price and quantity
	**Example:

const price = teaOrder.price;
const quantity = teaOrder.quantity;
const teaName = teaOrder.teaName;
	--now we have 3 standalone variables that originated from properties in our teaOrder object
	--we have not altered or mutated the object in any way
	--this method is obnoxious because we have to constantly write the name of the object
	--if we want to make multiple updates or alterations, this a tedious thing to do
**This is where destructuring comes in
	--we can on a single line exract or destructure any of the values out of the teaOrder object
	**Example:

const {price, quantity, teaName} = teaOrder;
	--above we chose the properties that we want out of teaOrder
	--then we set those props equal to the object
	--curly braces are essential
	--it tells JS that we are DESTRUCT the values into stand alone variables
	--now JS looks for each given property in the teaOrder object and verifies that each exists in the given object
	--so now we can code call price and see that it has the value of the property with the same name from teaOrder
	--again we have not altered the teaOrder object in anyway
	**IMPORTANT: Nothing we do with destructuring will ever mutate or alter the data structure we are working with in any way. All we are doing is 	seamlessly extracting and copying information from the data structure.

**What if the name we use in destructuring does not exist in the object we are extracting from??
	--we would just be creating a variable
	--if we use a name that doesn't match a property in the object and call that name, we will get undefined

**Another thing we can do is use rest operator in conjunction with destructuring
	--remember rest
	--function hi (...nums) would collect all arguments into a nums array
	--when used in destructuring it will create a new object with all the properties that are not named
	**Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

const {price, quantity, teaName,...otherStuff} = teaOrder;
	--now a variable named otherStuff has been created
	--in that variable is an object with the properties from teaOrder that weren't named in destructuring

**So far we've seen
	--we can create new variables using an existing object
		--we use name of prop we're looking for
	--we also saw we can collect the rest of the properties from the object in the same line

			11.9.15
			More Destructuring Objects
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64574

**With Destruct we can also set default values
	--let's continue with the teaOrder object from subunit 14
	**Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

const {brewTemp = 175) = teaOrder
	--we are adding a property to teaOrder that does not exist
	--we are simultaneously adding a value to that new property
	--let's say the property brewTemp already existed and had a value attached to it
	--the new variable created from destruct would default to value assigned within the object
	--if the property name does not exist, we can set the value in the destruct

**Renaming with Destruct
	**Example: 

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

const { teaName: tea} = teaOrder
	--this would change property called teaName and rename it to tea
	--we can combine defaults and renaming
	**Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

const { brewTemp: temp = 175} = teaOrder
	--now brewTemp is renamed to temp
	--and the default value (because it is not in the teaOrder function) is 175
**How can we use destruct with functions?
	--Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

function checkout(tea){
   const {quantity, price} = tea;
   return quantity * price;
}

console.log(checkout(teaOrder))
	--when we console.log checkout(teaOrder), we pass the teaOrder object as an argument of the function checkout.
	--inside the function, tea now refers to the teaOrder object.
	--this allows checkout to access quantity and price from teaOrder indirectly through the tea parameter.
	--then we can extract the quantity and price properties from teaOrder and use them in our function
	--the values for these properties are determined by the value assigned within the object referred to in call of checkout
**Let's see another example with a different teaOrder
	**Example:

const order1 = {
   variety: 'green',
   teaName: 'silver needle',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
};

function checkout(tea){
   const {quantity = 1, price} = tea;
   return quantity * price;
}

console.log(checkout(order1))
	--we removed the quantity prop from the object
	--now when we call checkout(order1) the value for quantity is determined from the value in the destruct

			11.9.16
			Array Destructuring
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64576

**We can use destruct on arrays as well
	--in objects we destruct based on property/key names inside an object
	--in arrays we destruct based on the index of item we're extracting
	--we also use [] instead of {}
	**Example:

const students = [
   {name: "Drake", GPA: 4.6},
   {name: "Henrietta", GPA: 4.4},
   {name: "Tung", GPA: 4.0},
   {name: "Harry", GPA: 3.8},
   {name: "Anthony", GPA: 3.2},
];

const [topStudent] = students;
	--the new variable we created tells JS to take the first array element and save it inside that new variable
	--so if we call topStudent we would get an object with the name: Drake and GPA: 4.6
	--if we want to include another student in the new variable we use a comma
	**Example: const [topStudent, secondbest] = students;
	--now we would have variable for topStudent with info for Drake and variable for secondBest with info for Henrietta
	--destructuring an array is all about the position of the element
	--so when I'm destructuring an array, the first thing in the destruct list will be the first thing in the new variable
	--the second in the destruct list will be the second
	--and so on and so forth
	--there is a way to skip elements however
	**Example:

const [topStudent, secondBest,,] = students;
	--the second comma is the first element we skip.
	--the third would mean skip 2 elements, and so on
	**Example:

const students = [
   {name: "Drake", GPA: 4.6},
   {name: "Henrietta", GPA: 4.4},
   {name: "Tung", GPA: 4.0},
   {name: "Harry", GPA: 3.8},
   {name: "Anthony", GPA: 3.2},
];

const [topStudent, secondBest,, fourth]
	--here it looks like we want to access the third element in the array
	--but because there is an extra comma after secondBest, we are skipping one element
	--that means that fourth is now saved as {name: 'Harry', GPA: 3.8} instead of {name: 'Tung', GPA: 4.0}
	--when skipping elements you shouldn't skip more than one at a time
	--that would involve counting commas and more "figuring out" than is needed
**IMPRTANT NOTE
	--as with objects, we are also not altering the original array in anyway
	--when we extract any number of elements with destructuring, the original array remains unchanged
**We can also use the rest operator when destructuring arrays
	--Example:

const [first, ...losers] = students;
	--here we have new variable called first with the info from the first object in the array
	--then we have a new variable called losers that contains the rest of the array

			11.9.17
			Function Destructuring
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64576

**Function destructuring
	--we can use this to extract key/value pairs from an object into variables
	--if we know we're passing an object or array into a function
	--and we need to use specific pieces of it
	--we can use destruct in parameter list to grab terms in their own variables
	**Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

function getTotal(tea){
   const {quantity, price} = tea;
   return quantity * price;
}
	--here we are destructuring within the function when we say const {quantity, price} = tea;
	--we could instead destruct in the parameter list and not even have to write const {quantity, price} = tea;
	**Example:

const teaOrder = {
   variety: 'oolong',
   teaName: 'winter sprout',
   origin: 'taiwan',
   price: 12.99,
   hasCaffeine: true,
   quantity: 3
};

function getTotal({quantity, price}){
   return quantity * price;
}
	--now we have can could call getTotal(teaOrder)
	--this will destruct quantity and price from the teaOrder object
	--then it will carry out the return of the function
	--everything else in the object is ignored because we haven't accessed it in any way
	--so we could also add in something like ({quantity, price, ...rest}) to include the rest of the object in a new variable
**We can do the same thing with arrays
	--suppose we have 2 arrays of results from something or another
	--where the first element is first place, the second is second place, and so on
	--we want a function that returns an object where the first property of the object is gold:, the second is silver: and so on
	**Example:

const longJumResults = ['Tammy', 'Jessica', 'Violet' ];
const swimMeetResults= ['Japan', 'France', 'Chile'];

function awardMedals(){
   return {
      gold: 'Tammy',
      silver:'Jessice'
   }
}
	--instead of list each element as a key/value pair, we can use destruct
	**Example:

function awardMedals([gold, silver, bronze]){
   return {gold, silver, bronze};
}
	--we call awardMedals and pass in the array we want to access as the argument
	--we don't even need to list the properties with the value in the return because of the object property shorthand
	--now when we call awardMedals(longJumpResults) we will get an object
		{gold: 'Tammy', silver: 'Jessica', bronze: 'Violet'}
	--so again we can destruct inside a function definition (parameter list)
	--we can do it both with arrays AND objects
	--it is far more common to do it with objects, though

			11.9.18
			Nested Destructuring
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64576

**We can combine what we know about destructuring arrays and objects
	--we can learn about destructuring nested objects/arrays
	--we destructure nested objects by nesting the curly braces in the destructuring statement
	**Example: 
	**NOTE ABOUT THE EXAMPLE: for this example, we're using a rating database from an api
	--I don't have access to the API and I don't want to copy it from the video because it's long and complicated
	--so we're just going to have to use our.... "IMAGINATION" when talking about this
	--.... carry on
	**Example:

const {Rated} = movie;
const {rating, advisory} = Rated;
	--here we are accessing the Rated object nested in the movie object
	--then we are accessing the rating and advisory properties in the Rated object
	--but we're using 2 steps to get access to what we really want which is the rating/advisory props
	--instead we can nest our destructuring
	**Example:

const {Rated: {rating, advisory}} = movie
	--in this example we've created 2 new variables for rating and advisory
	--we have not created a variable for Rated
	--that's because we are just using that to gain access to rating/advisory
	--we could rename the props that we are destructuring
	**Example:

const {Rated: {rating, advisory: notes}} = movie
	--here we have renamed the advisory prop to note
	--now we don't have an advisory variable, but a note variable instead
	--note will still access the value of advisory, the name has just been changed

**We can do the same with arrays
	--in the movie object with tons of props and methods and nested objects
	--there are also nested arrays
	--There is a Ratings array with user ratings
	--each element is an object
	--and each object contains a Source: and Value: prop 
	--let's say we want to destructure the first element in the array
	**Example:

const [Ratings] = movie;
const [imdbRating] = Ratings
	--this would create a variable called imdbRatings and save the info from the first element of movies in it
	--like with an object, this took 2 steps to get the info we want
	--we can use nested destructuring here as well
	**Example:

const [Ratings: [imdbRating]] = movie;
	--this will do the same thing as the first
	--what if we wanted to access the second element and skip the first?
	**Example:

const [Rating: , rottenToms]] = movie;
	--great! now we have created a variable called rottenToms which saves the information for the second element of movie array
	--what if we want just the value property of object that is the first element of the movie array?
	**Example:

const { Ratings: [{Value}]} = movie;
	--this gets deep, but follow along now
	--we first access the Ratings array, inside the movie object
	--then we access the first element of that array which is itself an object
	--then we access the Value property from that object, nested in an array (Ratings), nested in an object (movie)
	--now we have created a new variable that extracts the info we accessed which
	--the variable is called Value and has a value of '8.3/10'
	--we could also rename Value
	**Exmaple:

const { Ratings: [{Value: imdbRatingValue}]} = movie;
	--we're accessing the same thing as before, we've just given the new varibale a different name
	--we can continue down the list objects that are elements in the Ratings array
	--we just need to stay inside the square brackets[]
	**Example:

const { Ratings: [ {Value: imdbRatingValue}, {Value: rtRatingValue}, {Value: metaRatingValue} ]} = movie;
	--we are moving through each object of the array and pinpointing the value we want by using commmas in the destructuring

**Let's look at another example:
	--there is a Versions array which is a property of the movie object
	--again, each element of the array is also an object
	--these "element objects" contain 2 props, version: and runtime:
	--we want to extract both runtimes
	--but we want to combine this our original destructuring statement
	**Example:

const {
   Ratings: [
      {Value: imdbRating},
      {Value: rtRating},
      {Value: metaRating}
   ],
   Versions: [
      {runtime: originalReleaseRuntime}
      {runtime: directorsCutRuntime}
   ]

} = movie;
	--now we are accessing what we want and it's all pretty clear cut

**Nesting to 5 or 6 levels could become harder to understand
	--it is shorter, but shorter does not always mean better

			11.9.18
			Destructuring Swap
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64560/64576

**This is nothing new, just an application of destructuring
	--a common application where we use destruct to help
	--it's called swapping variables or swapping values
	**Example:

let delicious = "Mayonnaise";
let disgusting = "Whipped Cream"
	--without destructuring we would need to create a third temporary variable
	--otherwise if we try to set
delicious = disgusting
	and
disgusting = delicious
	--delicious would equal "Whipped Cream" and disgusting would equal "Whipped Cream"
	--because we set value of delicious to what was in disgusting
	--so we need a temp placeholder
	**Example:

let temp = delicious	// we set temp to equal "Mayonnaise"
delicious = disgusting	// we set "Mayonnaise" to equal disgusting
disgusting = temp;	// we set "Whipped Cream" to equal delicious
	--so here were are setting saving delicious (aka "Mayo") into the temp variable
	--this is so that we can change the definition of disgusting later
	--then we setting delicious (aka "Mayo") equal to disgusting (aka "Whipped Cream")
	--now delicious = "Whipped Cream"
	--then we set disgusting (still "Whipped Cream" because we made the temp variable) equal to temp
	--now disgusting is equal to "Mayo"
	--It's complicated, but we have a solution to this called swapping values
	--first we'll see the "longhand" way of achieving this
	**Example:

let delicious = "Mayonnaise";
let disgusting = "Whipped Cream"

let both = [delicious, disgusting];

[disgusting, delicious] = both;
	--now disgusting is equal to mayo and delicious equal to whipped cream
	--we can be even more succinct than this
	**Example:

[disgusting, delicious] = [delicious, disgusting]
	--we don't use let or const to declare a new variable
	--because we've used let already we can change the values
	--with const we wouldn't be able to
	--here we're just using destructuring to update existing variables
**Here's a review on swapping variables
	--we make an array
	--we put values into the array so that we can use it to swap existing values
	--we use destruct on left to set disgusting from whatever first element is to whatever second element is

**Here's a review of what we learned about destructuring in general
	1.) We can destructure objects and arrays
	2.) We can use rest to collect the rest of an object or array while destruct
	3.) We can rename the variables with colon and name we come up with
	4.) We can have Default values using the equals sign
	5.) We can destruct nested objects with {} and arrays with []
	6.) We can use it define a function in a parameter list (typical with objects)
	7.) We can us the one liner syntax for swapping values











