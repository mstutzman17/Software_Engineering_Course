Notes for Unit 11 Subunit 10

			11.10.1
			Callback Functions Revisited
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582

**Subset of built array methods that accept callbacks as arguments
	--array docs on MDN
	--there are tons of array methods
	--one such method is forEach method which accepts a callback
	--another is reduce

**Let's talk about functions as values in JS and how we can pass functions around
	--we have multiple ways of defining a function
	**Examples
1.) Defining a funciton

function holler() {
    console.log("Hey you!")
}

2.) Annonymous Function Expression
	--basically a function stored in a variable

const whisper = function() {
    console.log("pssst.... i have a secret")
}
	--let's rep here for second
	--to execute we can call whisper in the console
	--if we do that, we would get "pssst.... i have a secret" printed to the console
	--so this is where we will start into the meat of this video which is passing functions around
	**Example:

function add(x,y){
    return x + y;
}

function subtract(x,y){
    return x - y;
}

function multiply(x,y){
    return x * y;
}

function divide(x,y){
    return x / y;
}
	--above, we have 4 simple math functions
	--like a number or string, functions are values
	--we could even put functions inside an array
	**Example:

const mathFuncs = [add, subtract, multiply, divide]
	--it's important to note that you don't add the parens when you put functions into an array
	--if you do you are trying to execute the function right away
	--here we are just reference the value each function by putting the function name into the array
	--now let's say we wanted call one of these functions using the mathFuncs variable
	**Example:

mathFuncs[3](18,2)
	--here we are accessing index of 3.
	--in the mathFuncs array index of 3 references the divide function
	--so that is what function will be carried out

**Let's talk about callbacks (functions as arguments)
	--we've seen it before
	**Example:

const whisper = function() {
    console.log("pssst.... i have a secret")
}

setTimeout(whisper, 4000)
	--here we have set the first parameter to the name of the function
	--the second parameter is the amount of time to wait before the function passed an argument is carried out
	--it's important to note that we are not calling the function whisper.
	--the setTimeout method is calling the function
	--so we do not need the parens after the function name
**The question is how do we write our own functions that do this?
	--it's pretty straightforward
	--we treat them like any other argument
	**Example:

function doMath(a,b,mathFunc){
    return mathFunc(a,b)
}
	--here we have a function called doMath
	--the first two parameters are set as a,b but you can call them whatever you want
	--the third parameter is going to call a function (again the name can be whatever you want)
	--in the body of the function we are returning whatever math function we decided on and whatever numbers we decided on.
	**Example:

function doMath(a,b,mathFunc){
    return mathFunc(a,b)
}

console.log(doMath(17,27,add))
	--here we have successfully used a function as an argument

**We can also pass in an anonymous function
	**Example:

doMath(7,7, function(a,b){
    console.log(`Answer: ${a ** b}`);
})
	--as our third parameter here, instead of callback a function, we written an anonymous function that only exists in this block of code
	--in the example above we used an inline anonymous function

**What if we used the mathFuncs array and defined a function called do all math
	--this would accept 2 numbers and the mathFuncs array as 
	--we want it to call each function in the array and list the answers
	**Example:

function doAllMath(a,b, mathFuncs){
    for(let func of mathFuncs){
        console.log(`Answer: ${func(a,b)}`)
    }
}

console.log(doAllMath(7, 7, mathFuncs))
	--the doAllMath function accepts 3 parameters
	--we used a for loop to iterate over each value of the mathFuncs array
	--after the for loop we console.log the result
	--and voila, we've used an array as an argument in a function

			11.10.3
			forEach
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582

**We're talking about array methods that expect a function as an argument
	1.) First up is the forEach method
		--it's the simpliest one
		--not most powerful, not most useful, just easiest to understand
**How does it work?
	--Loops through an array
	--runs a callback function for each value in the array and then returns undefined
	--forEach will always return undefined - no matter what
	**Example:

const colors = ['teal', 'cyan','peach','purple']

colors.forEach(function())
	--this is the setup
	--often you would write an inline function for the argument of the forEach method
	--however, you can also call an existing function
	**Example:

colors.forEach(console.log)
	--if we run this code, the console will return the following:

teal 0 >Array(4)
cyan 1 >Array(4)
peach 2 >Array(4)
purple 3 >Array(4)
	--we see here that each color from our colors array are being individually printed, along with it's index and the entire colors array
	--this gives us insight into how forEach works
	--every function we pass into forEach can take/return 3 arguments
	--in the colors example teal is the first argument, 0 is the second argument, and the entirety of the array is the third argument
	--most often we will only use 2 arguments (the value and the index)
	**Example:

colors.forEach(function(val){
    console.log(val.toUpperCase())
})
	--here we're accessing the colors array and printing the uppercase value (val) of each element to the console
	--we could also write the function separately and pass the name of the function in as a callback
	**Example:

const colors = ['teal', 'cyan','peach','purple']

function yellColors(val){
    console.log(val.toUpperCase())
}

colors.forEach(yellColors)
	--this would do the exact same thing as the prior example
	--we could also use the index if we wanted to
	**Example:

const colors = ['teal', 'cyan','peach','purple']

function yellColors(val, index){
    const caps = val.toUpperCase()
    console.log(`At index ${index}: ${caps}`)
}

colors.forEach(yellColors)
	--here we have value AND index as parameters
	--we then logged a template literal to the console where we called our index and our value
**AGAIN
	--Most often we would use an inline function like our first example
	--but we could also use a callback function
	--first parameter is value of the element
	--second parameter is the index of the element
	--third value is the array(not commonly used)

**Let's try another example:
	--we have an array of prices
const prices = [30.99, 19.99, 2.5,99.0]
	--we could use forEach to sum up all of these prices
	--there are other ways to do it, but let's try forEach
	--we need to create a variable using let
	**Example:

const prices = [30.99, 19.99, 2.5,99.0]
let total = 0;
prices.forEach(function(price){
    total += price;
})
console.log(total)
	--here we forEach calls our anonymous function and passes in the first value of the prices array
	--total += price is taking the first element and adding it into the total variable
	--then the process repeates until the end of the array
	--and after that process is complete, the total variable is printed to the console
**The thought may occur that we could do this with any old regular loop
	--what about a for of loop
	--we actually could do this
	**Example:

const prices = [30.99, 19.99, 2.5,99.0]
let total = 0;
for( let price of prices){
    total += price;
}
console.log(total)
	--this would do the exact same thing
	--in fact it's cleaner and easier to understand
	--but the reason forEach exists is because for of loops are a more recent addition to JS
	--the difference between the 2 is that we don't use a callback or function in the for of loop
	--so it we had function that we wanted to use a for of loop for we would have to write the loop and call the function within the loop
	--with forEach we can just call the name of the function and be done with it
	--in the past forEach was easier than a regular for loop
	**Example:

const prices = [30.99, 19.99, 2.5,99.0]
let total = 0
for (let i = 0; i < prices.lenght; i++){
    total += prices[i];
}

			11.10.4
			Writing forEach
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582

**For this section of the unit we will be doing a practice exercise with forEach
**We are attempting to create a function that does the same thing the forEach method does
**Here are the requirements for the function
	1.) Loops through an array
	2.) Runs callback function on each value of array
	3.) Returns undefined

**My Attempt:

const myForEach = [4,5,6]

myForEach.forEach(function (value){
    console.log(value)
})

**The right way

function forEach(arr, callback){
    for(let i = 0; i < arr.length; i++){
        callback(arr[i])
    }
}

forEach(prices, function(price){
    console.log(price)
});

**Notes on my attempts
	--in my attempt I didn't follow the directions that were given.
	--I did successfully implement the forEach method while calling an inline, anonymous function
	--but I was supposed to create a function that loops through an array, runs a callback function and returns undefined
**Notes on the right way:
	--the version that I coded along with (the right way) does things, well what do you know, the right way
	--first there is a function called forEach with 2 parameters (arr, callback)
	--the function loops through each value of an array using a for loop
	--then we callback the arr at [i]

**Important to understand how forEach works**
	--it passes in the index as argument to callback second argument
	--in other words, the first parameter of forEach points to the value of the array, the second points to the index of that value, and third points to 	the array in it's entirety
	--that means we could also print the index of each price in the prices array
	--in order to do that, though, we have to pass through the index in our function
	--the only thing you need to change is adding that to the callback list in the function
	--and adding it to console.log list as well
	--the hardest part here is the callback
	--we're setting callback as a parameter and then calling it the same function
	--the thing, the callback function is not defined until we call our forEach function
	--then the callback function is an inline anonymous function and the second argument of the forEach function
**Pretty confusing, but we'll just build from here

			11.10.7
			map
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64588

****Array Methods Continued
	1.) First up is the forEach method
	2.) the map method
		--a very useful method for arrays in JS

**Goals with map
	1.) Understand wha map does
	2.) Be able to write our own version of map
**What is map?
	--creates a new empty array
	--iterates through an array
	--runs callback function for each value in array
	--returns new array
	--map always returns a new array of the same length as the original array
	**Example:

const numbers = [21, 37, 64, 99, 142]
numbers.map(function(num){
    return num * -1;
})
	--just like for each, the first argument of the callback is the value of each individual element in the array
	--in the above example we will get a new array.
	--if we call the original numbers array, it will remain the same
	--this is because map does not mutate or change the original array
	--for that reason we need to use a function expression
	**Example:

const numbers = [21, 37, 64, 99, 142]
const negatives = numbers.map(function(num){
    return ( num * -1);
})
	--what we're doing is saving the map method that's being used on the numbers array into a new variable
	--we do this because, again, map does not mutate the original array
**When working with map...
	--you need to make sure the callback function returns something
	**Example:

const doubles = numbers.map(function(num){
    console.log(num * 2)
})
	--we will not get an array returned, because the map method expects a return value in order to build the new array
	--what does console.log return?
	--if we look at the doubles variable we just defined we would get an array of undefined the same length as the numbers array

**Let's get more complicated
	**Example:

const toDos = [
    {
        id: 1,
        text: 'walk the dog',
        priority: 'high'
    },
    {
        id: 2,
        text: 'walk the chickens',
        priority: 'medium'
    },
    {
        id: 3,
        text: 'feed the cats',
        priority: 'low'
    },
    {
        id: 1,
        text: 'put out fire in garage',
        priority: 'very high'
    }
]
	--let's say we want to create an array with just the text property in each object
	--this a common use case of the map method 
		--when we have a more complicated data structure and want to extract specific pieces, but not all pieces of that data
	--how would handle this?
	**Example:

const toDoText = toDos.map(function (todo) {
    return todo.text;
})
	--map is iterating through each object of the array.
	--each object is considered 1 element
	--when it iterates through an object it is pulling out the value of the text property and putting it into a new array
	--it continues till the end and then we get a new array
	--in the new array we will have 4 elements
	--each element will be the value of the text property from the original objects in the original array

**Let's move on to a more realistic example:
	--we have a website that has 4 links
	--each link is to a different website
	--we want to extract the href from the link tag in the html
	--how the heck would we do that?
	--well, we use map and something called query selector
	**Example:
const links = document.querySelectorAll('a');
	--this would give us a NodeList which means that our array methods won't work on it
	--we can change it into an array though
	**Example: 
Array.from(links)
	--this gives us an actual array
	--now we connect it all
	**Example

const links = Array.from(document.querySelectorAll('a'));
const urls = links.map(function (a){
    return a.href;
})
	--now if we call the urls variable we will get an array 4 elements
	--each element is 1 href

**The return statement of a.href is different
	--if we type Array.from(links)[0] into the console it would return the first href in our ul from our html document
	--it does this because we have transformed the ul in our html document into an array us the Array.from method
	--we've also linked the each li from the ul to our JS by using the document.querySelectorAll method
	--so now each li in our ul from our html is an elment in our array in our JS
	--that means that Array.from(links)[0] is a reference to the first li in our ul
	--Array.from(links)[1] is a reference to the second li and so on and so forth

			11.10.8
			Writing map
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64588

**Same format as the writing forEach
	--just like forEach, our function will work slightly differently
	1.) We need to pass in the array
	2.) Then we would pass in our callback
	3.) The callback will return 3 different arguments if we want to accurately recreate how map works
	**Example:

myMap([1,2,3], function(val){
    return val * 3;
})
	--even though there is only one parameter, this should return a new array [3,6,9]

**Requirements
	1.) Define a function
	2.) The function needs 2 arguments (array, callback)
	3.) Make new empty array
	4.) Loop over array that is passed in
	5.) call callback once per item in the array
	6.) take return value and push it onto array
	7.) return that array at the very end

My Attempt:

function myMap(array, callback){
    const emptyArray = [];
    for(let i = 0; i < array.length; i++){
        emptyArray.push(callback(array[i]))
    }
} 

const newToDos = myMap(toDos, function(toDos) {
    return toDos
})
	--I know that this is not correct
	--I am a lot closer than I was last time, though

The Right Way:

1. function myMap(array, callback) {
2.    const mappedArray = []
3.     for (let i = 0; i < array.length; i++){
4.        mappedArray.push(callback(arr[i]))
5.    }
6.    return mappedArray;
7. }
8.
9. const priorityMap = myMap(toDos, function (priority){
10.   return priority.priority;
11. })
	--line 2 we start with a new, empty array
	--line 3 then we loop over the array that we want to call
	--line 4 we call the callback function AND we push that onto the mappedArray
	--line 6 we return the mapped array
	--line 9 we save our myMap function into a new variable called priorityMap
		--the variable executes the myMap function on the toDos array.
		--the parameter of the function is one element of the array
	--line 10 we return the element of the array that we want
		--in this case we are extracting the priority property from each object in the toDos array

**IMPORTANT TO REMEMBER
	--the map method always returns 3 arguments
		1.) The value of the element
		2.) The index of the element
		3.) The entire array
	--in our above example we could add to line 4
		--mappedArray.push(callback(array[i], i, arr))
	**Example:

1. function myMap(array, callback) {
2.    const mappedArray = []
3.    for (let i = 0; i < array.length; i++){
4.        const val = callback(array[i], i, arr)
5.        mappedArray.push(val);
6.    }
7.    return mappedArray;
8.}
9. 
10.  const repeatedLetters = myMap(['a', 'b', 'c', 'd', 'e', ], function(str, idx){
11.    return str.repeat(idx);
12. }) 

	--line 4 we created a variable to store our values for our parameters in
	--line 5 we're pushing those values into the new array
	--line 10 we call our function on a new array (the one that's inline)
		--we have an inline function that accepts 2 parameters
		--we save the function to the variable
	--line 11 we're using string.repeat method
		--this allows us to repeat a string ("lol".repeat(4) would b "lollollollol" 
		--we repeat each string idx times.
		--this means that we are repeating each string based on the index of that string ('a' repeats 0 times, 'b' once, 'c' twice, and so on
		--we need a return otherwise we'll get a bunch of undefined

**Here's a couple scenarios where you would use map method
	--you want to "transform" an array into another array of the same length
		--you wanna take a piece of data for each element in an existing array
		--and then you want to doing something with that element (double it, add, subtract, extract)
		--extracting is most common
		--like you want to extract the price from a list of items or something along those lines
	--you do not want to overwrite an existing array and instead return a new copy

**Review
	--map creates new array
	--map runs a callback on each value and pushes the result of each callback in the new array

***It is the difference between this:


const numbers = [21, 37, 64, 99, 142]
const negatives = numbers.map(function(num){
    return ( num * -1);
})

***And this:

function myMap(array, callback) {
    const mappedArray = []
    for (let i = 0; i < array.length; i++){
        const val = callback(array[i], i, array)
        mappedArray.push(val);
    }
    return mappedArray;
}

const repeatedLetters = myMap(['a', 'b', 'c', 'd', 'e', ], function(str, idx){
    return str.repeat(idx);
})


			11.10.11
			filter
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64592

****Array Methods Continued
	1.) forEach method
	2.) map method
	3.) filter method
		--instead of mapping each element it creates new array where we filter based on a condition
**Goals
	1.) Understand what filter does
	2.) Write your own filter function

**How does filter work?
	--creates new array
	--Loops through an array
	--runs a callback function on each value in the array
	--if callback is true value is pushed to new array
	--if callback function false, value will not be included in the new array
	--result of the callback will always be evaluated into a Boolean

Let's see an example of the filter method
	**Example:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'pseudopseudohypoparatahyroidism',
    'immunoelectrophoretically',
    'unimaginatively'
]

const longWords = words.filter(function (word){
    return word.length >= 20;
})
	--this will create an array with words that have 20 or more characters
	--it is referencing the words array above
	--so if we call longWords, it will return an array of 3 items with 20 or more letters
	--we can also create a new array for words that start with u or c
	**Example:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'pseudopseudohypoparatahyroidism',
    'immunoelectrophoretically',
    'unimaginatively'
]

const randomWords = words.filter(function (w){
    return w[0] === 'u' || w[0] === 'c'
})
	--this creates an array with words that start with the letter 'u' or 'c'

**We can get even fancier
	--we want to create a new array with words that do not have vowels in them
	**Example:

const containsVowel = function(word){
    for (let char of word){
        if(isVowel(char)) return true;
    }
    return false;
}

const randomWords = words.filter(function (w){
    return w[0] === 'u' || w[0] === 'c'
})

const vowelWords = words.filter(containsVowel)
const noVowels = words.filter(function(word){
    return !containsVowel(word)
})
	--we create variable called isVowel
	--the variable has function that accepts a character
	--returns true or false if character is or isn't a vowel
	--then we make a string of the vowels and check if the any of them are in the word using indexOf
	--if it's false it will return -1, if true a positive 1 is returned
	--we set this 'aeiou'.indexOf(char) != -1 so that we can avoid the vowels
	--then we make a variable called containsVowel with a function that accepts a word
	--we us a for of loop to determine whether each letter in the word is a vowel or not
	--we do this by using an if statement on the isVowel function
	--so if the word contains a vowel the if statement returns true
	--if we make it through every character of a word and there aren't any vowels, that statement will return false
	--then we can pass in the containsVowel function saved in a variable to the noVowels variable
	--if it returns true, the word will be added to the filtered array
	--so it doesn't work how we want it to
	--now we need to create another variable with a custom function
	--this function will return the opposite of containsVowel
	--so now if we filter will create an array with words that DO NOT contain vowels

			11.10.12
			map and filter
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64592

**Another example of using filter with some dom elements
	**Example:

const allCheckboxes = document.querySelectorAll('input[type="checkbox"]')
	--so we start by selecting all of the input type='checkbox' list items from our html doc
	--we can then filter only the checked checkboxes
	--the only problem once again is that allCheckboxes is not an array
	--so we have to turn it into one
	**Example:

Array.from(allCheckboxes)
	--now we have an array called allCheckboxes
	--we can then use the 'checked' property to see if which elements are and are not checked
	**Example:

Array.from(allCheckboxes)[0].checked
	--this would return true because the [0] (first element) is a checked checkbox
	--Array.from(allCheckboxes)[1].checked would return false because the second element (index of 1) is not a checked checkbox
	--now we can move on and use the filter method to create an array with only checked inputs
	**Example:

const allCheckboxes = document.querySelectorAll('input[type="checkbox"]')

const checked = Array.from(allCheckboxes).filter(function (box){
    return box.checked;
})
	--now we have array with all the inputs that are checked on the todo list
	--what if we wanted to know which things are done
	--we could just call checked.lenght and would tell us how many tasks we completed
	--but we want to know how many tasks AND which tasks were completed
	--we could use map to accomplish
	**Example

const completedItems = checked.map(function (checkbox){
    return checkbox.parentElement.innerText;
})
	--we have an array of checked boxes
	--for each one we create new array where we access parent li element and access the inner text for that li element
	--then we return that text as an element in the new array that the map method is creating
	--so now we have a new array that tells us which items we completed that day
	--we could cut down some steps in this process
	**Example:

function extractCompletedTodos(){
    const allCheckboxes = document.querySelectorAll('input[type="checkbox"]')
    return Array.from(allCheckboxes).filter(function (box){
        return box.checked;
    })
    .map(function (checkbox){
        return checkbox.parentElement.innerText;
    })
}
	--now we've combined each step of the process into one function
	--in the function we have a return statement that runs the .filter and .map methods to create a lovely new array

			11.10.13
			Writing filter
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

**Now we want to write our own code that will behave like the filter method would
	--our version needs to accept an array first myFilter(arr, callback)

**My Attempt:

I honestly can't manage an a well thought out attempt right now. So I will rely on the "Right Way" to teach and guide me.

**The Right Way:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'cysts',
    'pseudopseudohypoparatahyroidism',
    'unimaginatively'
]

1. function myFilter(arr, callback){
2.    const filteredArray=[]
3.    for (let i = 0; i < arr.length; i++){
4.        if(callback(arr[i], i, arr)){
5.            filteredArray.push(arr[i])
6        }
7    }
8    return filteredArray;
9 }

10 const shortWords = myFilter(words, function(word){
11    return word.length<=10;
12 })
	--line 1 we define our myFilter function
	--it accepts an array and a callback function(arr, callback)
	--line 2 we create a filterArray variable that we can push our elements into
	--line 3 we need a for loop to iterate through the array that we choose
	--line 4 we need an if statement
	--the if statement calls the callback on the index of i, the index of the array and the arr itself
	--line 5 if everything in the callback is true we push the arr[i] to the filteredArray
	--if not, we move on
	--line 8 at the end of the function we are returning the filtered array which will have all the correct information
	--line 10 we create a variable called shortwords
	--line 10 we set the variable equal to our version of myFilter (the myFilter function)
	--line 10 when we call this function we reference the words array
	--line 10 then we write an inline function that determines our condition 
	--line 11 our condition is words that are 10 or less letters long
	--if we call the shortWords variable we get an array that has pulled out any word that is 10 or less letters from the words array

**We could also use the index that the filter method returns
	--let's filter our everyother word based on the index
	--so we're making a new array with every even index
	**Example:

const evenIndex = myFilter(words, function(word, i){
    return i % 2 === 0
})
	--now every other word in the words array is put into a new array
	--we did this by using the index parameter that is also native to the filter function (just like map and forEach)























