11.4 Notes

			11.4.1
			What is a Data Structure
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**What is a data structure and what is an algorithm?
	--simplified definitions
	--Say you've been buying books and you have simply organization scheme of stacking books on top of the other.
	--if you want to find a book unstack until you find the one you want
		--data structure as stack
		--algorithm as taking books off stack until we find the one we want
	--as you obtain more books you organize by authors alphabetically
		--data structure is book shelf 
		--algorithm is search process
	--you obtain more books
	--organize groups of shelves into fiction and non-fiction
	--organize each shelf into specific genre (fantasy, thriller, biographical, historical)
		--data structure is hierarchical organization of books
		--algorithm is process by which you identify genre and find book

**Let's simplify the definitions of data structure and algorithm
	--Data Structure: is a way to organize information
	--Algorithm: a way to process information to reach an end goal

**Motivating Questions 
	--Why use on organization scheme over another?
	--How do we measure performance of these schemes?
	--What type of problems do these ideas solve?

			11.4.2
			10 Key Data Structures Used Everyday
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**Data structures are critical concept for software developers**

**10 Types of Data Structures
	1.) Lists
		--versatile and essential DS in SD
		--great for storing and manipulating ordered data
		--used in task management, shopping list and social media applications
	2.) Arrays
		--provide fixed size order collection of elements
		--well suited for situations where collection size is known and doesn't change frequently
		--used commonly in mathematical operations
		--EXAMPLE: weather app array can be used for specific temps in certain region over period of time
	3.) Stacks
		--follow last in first out principle
		--perfect for sorting redo and undo operations
		--in text editor stack can be used to store each change in a document making it easy to trigger undo operation
	4.) Queues
		--operate on first in first out basis
		--can also manage printer jobs, sending user actions in games, handling messages in chat apps
		--in chat apps, a que can be used to store incoming messages in order received
		--ensures messages are displayed to recipient in correct sequence
	5.) Heaps
		--used for task scheduling and memory management
		--helpful in implementing priority queues
	6.) Trees
		--organize data hierarchically
		--useful for representing data with natural hierarchies or relationships
		--can be used in apps like data base indexing, AI decision making, file systems
		--AI decision making decision trees are use in machine learning for classification tasks
		--in data base indexing they help speed up search, insert or delete operations
		--EXAMPLE: b trees and b+ trees are commonly used in relational data bases to efficiently manage a large amounts of data
	7.) Hash Tables
		--allow for efficient data lookup, insertion and deletion
		--use hash function to map keys to corresponding storage locations
		--enables constant time access to stored values
		--used in apps like search engines, caching systems, and programming language interpreters or compilers
		--in search engines, hash tables can be used to store or retrieve index data based on key words
		--provides fast and relevant search results
		--caching systems use hash to store and manage data
		--allows for rapid access to frequently requested resources
		--EXAMPLE: Implementation of simples tables in programming language interpreters or compilers
		--efficiently manage and lookup variables, functions and other symbols defined in source code
	7.) Suffix Trees
		--specialized for searching strings in documents
		--makes them perfect for text editors and search algorithms
		--in search engine suffix tree used to efficiently locate all occurrences of search term within large amount of text
	8.) Graph
		--all about tracking relationships and finding paths
		--invaluable in social networks, recommendation engines, and pathfinding algorithms
		--in social network, graph used to represent connections between users
		--enables features like friend suggestions
	9.) R-Trees
		--good at finding nearest neighbors
		--crucial for mapping apps and geolocation services
		--in mapping app, used to sort spatial data like points of interest
		--enables efficient queries to find locations based on current position

**Cache Friendliness
		--CPU cache is small fast memory between main memory and CPU
			--stores recently accessed data and instructions so CPU can access them quickly without fetching from slower main memory
		--different data structures have varying levels of cache friendliness based on how elements are stored in memory
			--contiguous memory storage (Arrays) allow for better cache locality resulting in improved performance
			--when array element accessed cache can prefetch and store nearby elements anticipating that they m ight be accessed soonb
		--data structures with non contiguous memory stories (linked Lists)
			--can experience more cache misses and reduced performance
			--elements are store in nodes scattered throughout memory
			--each node contains pointer to next node
			--makes it difficult for CPU to predict and lode next node
		--Trees, hash tables, graphs have varying degrees of cache friendliness based on implementation and use case
			--disparity in access times can lead to performance issues in modern computing
			--particularly when cache misses occur frequently 
			--be mindful when working with performance critical apps
			--choose appropriate data structure based on specific requirements and constraints of project

			11.4.3
			Lists ADT
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**Arrays and Linked Lists Goals
	1.) Describe "abstract data type"
	2.) Compare different types of arrays
	3.) define singly and doubly linked lists
	4.) Compare performance characteristics of arrays and lists
	5.) Implementing linked lists in JavaScript

**Lists are an abstract data type
	--it describes a set of requirements, not an exact implementation
	--general requirements
		--can keep multiple items
		--can insert or delete items at any position
		--can contain duplicates
		--preserves order of items
	--Arrays are considered lists
	--Linked lists are another types of list
		--single link
		--double link
	--some lists don't meet EVERY requirements

			11.4.4
			Array Big O
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**How do Arrays actually work?
	--arrangement of items at equally-spaced addresses in memory
		[3,7,2,4,1,2]
		imagine them each being stored in a parking space

**Array Runtimes
	--retrieving by index
		--constant time 0(1)
		--because we have address to find specific element
	--finding
		--is ther "2" or "0" in this array
		--worst case you potentially have to look at every single element in array
		--0(n)
	--general insertion or general deletion
		--0(n)
		--when you insert or delete you have to shift everything
		--one operation for every element
		--depends where you're inserting or deleting

			11.4.5
			Direct Arrays
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**Direct Arrays/Vectors
	--only work if items are same size
		--all numbers (8 bit or 64 bit numbers
		--all same-length strings

**Instructional Website
	--onlinegdb.com/online_c_compiler

**Example of C compiler and how it stores elements
int main()
{
  int nums [3];
  nums[0] = 3;
  nums[1] = 5;
  nums[2] = 6.875;
  printf("%d", nums[2]);
}
	--this code returns 6 because the int nums [3] allocated a specific size space for each element. 
	--6.875 is bigger than the allocated space
	--if we had nums[2] = "hello world!" and did printf("%d", nums[2]), the string turns into a number

**Typed Arrays
	--JS provided direct array/vector
	--very uncommon
	--mdn docs "JavaScript typed arrays"
	--different kinds of type arrays
		--Int8Array (-128 to 127)
		--Uint8Array (0 to 255)
		--Int16Array (-32768 to 32767)
	--common theme is typed arrays have restriction of what can be stored

**Int8Array Syntax
	--new Int8Array(); // new in ES2017
	--new Int8Array(length)
	--new Int8Array(object)
	--new Int8Array(buffer [, byteOffset [, length]])

**Type arrays are very different from normal JS arrays
	--no .push or .pop method
		
**Exmaple of Uint8Array
	const numbers = new Uint8Array(3)
	--when you call numbers JS returns Uint8Array(3) [0, 0, 0]
	--numbers[0] = 67 returns Uint8Array(3) [67, 0, 0]
	--numbers[1] = 7999 returns Uint8Array(3) [67, 63, 0]
	--this is because the space allocated in Uint8Array 
	--type arrays are more efficient than regular JS arrays (indirect arrays)
	
**Indirect Arrays (typical JS array)
	--array doesn't directly hold the value
		--it holds the memory address of the real value
	--let's an array store different types of data or different length data

**Example of standard JS array (Indirect Array)
					(myIndirectArray)
	actual memory 	   ----->	[1] 	[2] 	[3] 
reference to placehold    ----->	[ant]	[bee]	[caterpillar]
	--elements are not stored in actual memory, but referenced from a placeholder

**Motivation of typed arrays is they are faster and more powerful but far more rigid

**What does JS use?
	--indirect arrays -- since you can store different length things in them
	--it's complicated, though: some implementations have specialized (smarter) or adaptive structures to handle edge cases like sparse arrays
	--point is there are different ways to store data

			11.4.6
			Linked Lists Intro
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**Arrays are just one example of abstract data type lists
**Linked Lists are another type
	--in linked lists items aren't stored in contiguous memory
	--instead, each item references the next item in the sequence
	**Example
	-- head[22]--->[2]--->[77]--->]--->[6]--->[43]--->[76]--->[89]tail

**Within an array
	--elements are stored next to each other physically in memory
	--can't arrange without having to move other items in memory
	**Example: [3,7,2,4,1,2]
		--to remove 7 form the above area, JS has to move every element over to fill the space that 7 occupied
		--if the array had 1 million elements and you wanted to remove or add an element from the beginning, it would take 1 million operations to 		  so.
		--It's very expensive if you have a long array

**With linked lists
	--we can remove, add, or move something at constant time
	--this is a lot faster than having to move everything around in a big list
	--can rearrange without having to move other items in memory
	**Downside
		--we don't have access to each individual element
		--can't point to an index of the list
		--all data structures have trade offs
		--linked lists have to be implemented in JavaScript
		--they are not a part of JS like arrays or objects

**How can we insert something into a linked list?
	--visualgo.net/en/list
	--if you want to add something to the beginning of a linked list you have to change the head to whatever you want it to be

			11.4.7
			Linked Lists -- Computerphile
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496

**Example
	-- [1][.]--->[2][.]--->[3][.]
	--if you want to add 0 to that list you can add it anywhere because it will automatically point to the next node.
	-- head--->[0][.]--->[1][.]--->[2][.]--->[3][.]<---tail
	--think of a treasure trail. you find one thing and it points you to the next
	--if you want to find a specific item in a linked list, you have to go through the entire list.
	--items are stored arbitrarily in memory
**adding an item between elements
	-- head--->[0][.]--->[1][.]--->[2][.]--->[3][.]<---tail
	--if you wanted to add 26 to the list above you would have to first cancel the link between 1 and 2
	--then you would have to add two pointers
	--first from 1 to 26 and then from 26 to 1
	--insertion into a linked list is constant time O(1)
	--searching a linked list is liner time O(n) which means the longer the list, the more time it will potentially take to search if a specific item 	exists within the list

**Dual linked lists
	--dual linked lists point both ways from each node
	**Example:
	--         [.][0][.]--->[.][1][.]--->[.][2][.]--->[.][3][.]
	--         [.][0][.]<---[.][1][.]<---[.][2][.]<---[.][3][.]	
	**Real World Example of Dual Linked List
		--Imagine you're using a web browser.
		--You open a website and click on a link
		--From that link you click on another link
		--And then another and another and another
		--This is a dual linked list because you can then use the back and forward arrows move backward in the list or forward in the list.
	**Example:
		-- [.][Main Page][.]--->[.][NASA][.]--->[.][Neil Armstrong][.]--->[.][Apollo 11][.]
		-- [.][Main Page][.]<---[.][NASA][.]<---[.][Neil Armstrong][.]<---[.][Apollo 11][.]
		-- from Apollo 11 you go back to the NASA page.
		--at this point you can still go forward to Neil Armstrong and Apollo 11
		--however, if you click an ISS link on the NASA page, the forward history link changes
		--you can no longer go forward to Neil Armstrong or Apollo 11 because the chain has been broken and the link moved to ISS

			11.4.8
			Linked Lists Continued

**Singly-Linked Lists
	--So far we've only had one kind of data structure for representing collections of like values
		--structs, recall give us "containers" for holding variables of different data types, typically
	--arrays are great for element lookup, but unless we want to insert at the very end of the array, inserting elements is quite costly -- remember 	insertion sort?
		--a lot of expense involved to pick something up and put in the middle
	--Arrays also suffer from a great inflexibility -- what happens if we need a larger array than we thought?
	--Through clever use of pointers, dynamic memory allocation, and structs, we can put the pieces together to develop a new kind of data structure 	that gives us the ability to grow and shrink a collection of like values to fit our needs.
	--combination of elements, when used in this way is a linked list
	--a linked list node is a special kind of struct with two members:
		--data of some data type (int, char, float...)
		--a pointer to another node of the same type
	--in this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end.

**How does this look in JS?
	-- typedef struct sllist {
    VALUE (any data type (int, float)) val;
    struct sllist* next;
} 
sllnode; 
	--sllnode is the ultimate name we want for this data type
	--sllnode is not defined until we are outside of the typedef.
	--temporary name is struct sllist
	--sllnode is permanent name and sllist is temporary name

**Singly-Linked Lists
	--in order to work with linked lists effectively, there are a number of operations that we need to understand:
1.) Create a linked list when it doesn't already exist.
2.) Search through a linked list to find an element.
3.) Insert a new node into the linked list. 
4.) Delete single element from a linked list
5.) Delete an entire linked list.

**Pseudo code for visualizing a linked list
	--create a linked list
		--sllnode* create (VALUE val);
**Steps involved
	a.) Dynamically allocate space for a new sllnode
	b.) Check to make sure we didn't run out of memory
	c.) Initialize the node's val field
	d.) Initialize the node's next field
	e.) return a pointer to the newly created sllnode
**What might this look like visually?
	--sllnode * new = create (6)
	a.) Dynamically allocate space for a new sllnode
	b.) Check to make sure we didn't run out of memory 	[][]
	c.) Initialize the node's val field 	[6][]
	d.) Initialize the node's next field 	[6][null]
	e.) return a pointer to the newly created sllnode 	new--->[6][null]
**How to search through a linked list to find an element
	-- bool find (sllnode* head, VALUE val);
	--the first parameter inside the parenthesizes is to keep track of the first element in the list
		--this is important because if you know the first element, the rest are linked to it
	--the second parameter inside the parenthesizes is the value type (int, string, float, ect.)
**Steps involved
	a.) Create a traversal pointer pointing to the list's head.
		--Why not just move the pointer we already have?
		--it's better to create a duplicate that moves away from the first element
	b.) If the current node's val field is what we're looking for, report success.
	c.) If not, set the traversal pointer to the next pointer in the list and go back to step b
	d.) If you've reached the end of the list, report failure
**Example of singly-linked list
	--function call: bool exists = find (list, 6)
	-- list--->[2][.]<---trav
	-- list--->[2][.]--->[3][.]--->[5][.]--->[6][.]--->[8][.]<---tail
	-- trav--->[3][.]--->[5][.]--->[6][.]--->[8][.]<---tail
	-- trav --->[5][.]--->[6][.]--->[8][.]<---tail
	-- trav --->[6][.]--->[8][.]<---tail
	--if the number we're looking for is not in the linked list, what happens?
	--once we get to the end of the list we try to go the next pointer
	--this will not work, so we return false
**Inserting a new node into the linked list
	-- sllnode* insert(sllnode* head, VALUE val);
**Steps involved:
	a.) Dynamically allocate space for a new sllnode
	b.) Check to make sure we didn't run out of memoruy
	c.) populate and insert the node AT THE BEGINNING OF THE LINKED LIST
		--reason being because inserting at end of list would be O(n) time complexity
		--it's easier to add to the beginning because that's where we're already at
	d.) return a pointer to the new head of the linked list
**Visualization
	--list = insert (list, 12);
	-- list--->[15][.]--->[9][.]--->[13][.]--->[10][.]<---tail
	-- new--->[][]
	-- new--->[12][.]
**What should we do after we've inserted 12?
	--Which point should we move first? Should the "12" node be the new head of the list, since it now exists, or should we connect it to the list 	first?
	--This is one of the trickiest things with linked lists. Order matters!
	--if you move things out of order you orphan the rest of the list
	**Example: moving 12 to the new head of the list would look like this
	-- list--->[12][?]<---new [15][.]--->[9][.]--->[13][.]--->[10][.]<---tail
	--there is no pointer from 12 to the rest of the list
	--the computer doesn't know because we have not told it
	--what we need to do instead is connect the pointer to the old head of the list first
	-- [12][.]<---new--->list--->[15][.]--->[9][.]--->[13][.]--->[10][.]<---tail
	--then we can move the list over
	-- list--->[12][.]<---new--->[15][.]--->[9][.]--->[13][.]--->[10][.]<---tail
	--correct order is connecting new element into list and then changing the head of the list
	--trying to do this in the opposite order will result in a loss of the list
**Delete an entire linked list
	-- void destroy(sllnode* head);
**Steps involved
	a.) If you've reached a null pointer, stop.
	b.) Delete the rest of the list
		--what does this step sound like?
		--that's recursion
	c.) Free the current node
**Visual Example
	-- list--->[12][.]--->[15][.]--->[9][.]--->[13][.]--->[10][.]<---tail 	[destroy()]
	-- list--->[15][.]--->[9][.]--->[13][.]--->[10][.]<---tail		[destroy()]
	-- list--->[9][.]--->[13][.]--->[10][.]<---tail				[destroy()]
	-- list--->[13][.]--->[10][.]<---tail					[destroy()]
	-- list--->[10][.]<---tail						[destroy()]
	-- list--->[.]<---tail							[destroy()]
**What would happen if we didn't do this correctly?
	--we would have had a memory leak

			11.4.9
			Node Class Implementation
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64504

**Linked list is a collection of nodes
	--each node is a value and a pointer
**A basic Node has two attributes:
	--val
		--the info of the node contains (could be string, people, url, number, boolean, browser history, int, instance, ect)
	--next
		--reference to next node (for last item, this is null)
	**Example:
		-- [ant][.]--->[bee][.]--->[caterpillar][.]--->null
		-- antNode; 
		   {val: "ant, next: beeNode]
		-- beeNode;
		   [val: "bee, next: caterpillarNode}
		-- caterpillarNode;
		   {val: "caterpillar", next: null}
**We can implement our own node class
	 class Node {
    constructor(val){
        this.val = val;
        this.next = null;
    }
}

const firstPage = new Node ('google.com')
const secondPage = new Node ('reddit.com')
const thirdPage = new Node ('amazon.com')

firstPage.next = secondPage;
secondPage.next = thirdPage

google => reddit => amazon => null

	--what is going on up there?
	--the first part of the syntax defines the Node class
	--each node will look like this: Node {val: 'google.com', next: Node}
	--when we get to the end of the list: Node {val: 'amazon.com', next: null]

**You can also make a Node class that accepts optional next argument
	**Example:
		class Node {
    constructor(val, next=null){
        this.val = val;
        this.next = next;
    }
}
	--this would allow us to add a chain of nodes like the following

let antNode = new Node ("ant",
                new Node ("bee",
                    new Node ("caterpillar")));
	--ends up exactly the same but can be hard to read at first
**Example

	class Node {
    constructor(val, next = null){
        this.val = val;
        this.next = next;
    }
}

const firstPage = 
    new Node('google.com', 
        new Node ('reddit.com', 
            new Node ('amazon.com')))
	--you can add an entry to the list
	**Example:
		-- firstPage.next.next.next new Node ('twitter.com')
	--firstPage.next gets us to reddit
	--firstPage.next.next gets us to amazon
	--firstPage.next.next.next gets us to null where we can add another Node

			11.4.10
			List Class
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64504

**How to add parent class to manage our list and give us methods to use
	**Something like this
	const history = new LinkedList();
	history.push('google');
	history.push(amazon')
	history.remove

**All a linked list needs is a reference to the very first node
	--that's all we need to get to every other value
	--beginning is called head
	--end is called tail
**How does it look and work?
	**Example:
		--the original code is this:
			
			class Node {
    constructor(val, next = null){
        this.val = val;
        this.next = next;
    }
}

const firstPage = 
    new Node('google.com', 
        new Node ('reddit.com', 
            new Node ('amazon.com')))

		--The improved code adds the following:

		class LinkedList {
    constructor(){
        this.head = null; //head is how we manage new linked list
    }
}

const history = new LinkedList()
history.head = firstPage; 
	
	--all the previous code is doing is adding a pointer to the head of the list

**Visualization
	--empty linked list
		-- [LList][head]=>null
	--linked list with nodes in it:
		-- [LList][head]=>[ant][next]=>[bee][next]=>[caterpillar][next]=>null
**Things we may want to do with a linked list
	1.) Print each node
	2.) Find a node by its data
	3.) Append to end
	4.) Insert at specific position
	5.) Remove node

			11.4.11
			Traversing Lists
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64507

**Methods for Traversing a List
	--Linked list a reference or pointer to the head of the list
	--to traverse we need to start with the head and print out each element
	--then ask for .next
	--print value
	-- .next
	--etcetera, etcetera
	--keep going until we hit the end and there is no next

**Example of Traverse

	class Node {
    constructor(val, next = null){
        this.val = val;
        this.next = next;
    }
}

class LinkedList {
    constructor(){
        this.head = null;
    }
    traverse(){
       console.log(this.head.val);
	console.log(this.head.next.val)
	console.log(this.head.next.next.val)
        }
    }
}

const firstPage = 
    new Node('google.com', 
        new Node ('reddit.com', 
            new Node ('amazon.com',
                new Node ('youtube.com')
            )))

const history = new LinkedList()
history.head = firstPage;
	--this function is hard coded which can pose a problem if the list is thousands or even hundreds of elements long
	--the reason is because you would have .next through every element of the list
	--instead we can use a loop

**Using a loop to traverse a linked list
	
	class LinkedList {
    constructor(){
        this.head = null;
    }
    traverse(){
       let currentNode = this.head;
        while(currentNode){
            console.log(currentNode.val);
            currentNode = currentNode.next;
        }
    }
}
	--first we set currentNode to be equal to this.head (the start of the list)
	--then use a while loop so that while the there is a currentNode we console.log the value of the current node (console.log(currentNode.val))
	--then we set currentNode equal to currentNode.next to cycle through the list
	--when the list ends there will not be a .next so the while loop will end

**How to search for something in a linked list
	--searching is like printing but we stop searching once we find what we're looking for
	--we want to know if some number is in the list
	**Example: is 77 in the list?
		--the list is searched until the number is found
		--if number is not in the list it still searches every element

**Example
	--we will traverse the list

  find(val) {
        let currentNode = this.head;
        while(currentNode){
            if(currentNode.val === val) return true;
            currentNode = currentNode.next;
        }
	return false;
}
}
	--we start the same as we would with the traverse loop
	--the loop will run while there is a currentNode
	-- if the currentNode.val equals the value we are searching for it will return true
	--if it's not the number we are searching for it will move to the next element in the list
	--if we go through the whole list and the number we're looking for is not in it, the code will return false
	--in the example above if we searched for 'NYTimes.com' we would get false because it's not on the list
	--if we searched for 'amazon.com' we would get true because it is on the list

			11.4.12
			Appending Nodes
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64507
**Appending a Node
	--how do we append a node to the end of a linked list?

	[LLIST][head] => [ant][next] =>[bee][next] =>[caterpillar][next] => null
	--cannot find the end unless we traverse last node and then set it's .next
	**Example:

	append(val){
    let currentNode = this.head;
    while (currentNode.next){
        currentNode = currentNode.next
    }
    console.log("at the last node", currentNode.val)
}
	--use while(currentNode.next) to help us stop before we get to null as current node
	--we want to get to the last node where null is .next
	--this code will not append anything, but it will get us to the last node
	**Example of appending the list:

	append(val){
    let currentNode = this.head;
    while (currentNode.next){
        currentNode = currentNode.next
    }
    currentNode.next = new Node(val)
}
	--currentNode.next = new Node(val) will add the new value to the end of the list
	--if we run history.append('twitter.com') twitter.com will be added to the end of the list
	--with this method we have to walk through every element of the list and then add a new Node
	--there is a better way

**Better way to append a list
	--it would be faster if we could know the end at all times
	--with a simple change we can keep track of the end
	--new linked list class will keep track of the head AND the tail
	--to append something we just need to make a new Node
	**Example
		
		append(val){
        const newNode = new Node (val) 	//we start by making the new node
        this.tail.next=newNode 		//then we take this.tail.next and point it at the newNode
        this.tail = newNode; 		//then we declare this.tail as the newNode
    }
	--the problem with the current setup is that the tail will always be pointing at null
	--there's another way to set it up
	**Example:
	
	append(val){
        const newNode = new Node (val)
        this.tail.next=newNode 		
        this.tail = newNode;

	const train = new LinkedList();
	train.append ('Engine')
		--with this list, there are no nodes so the head and the tail are pointing to "Engine"
		--in order to fix this, we can update the append function
	
	   append(val){
        const newNode = new Node (val)
        if(!this.head){
            this.head = newNode;
            this.tail = newNode;
        }
        this.tail.next=newNode 
        this.tail = newNode;
    }

	const train = new LinkedList();
train.append ('Engine')
train.append('Freight Car 1')
train.append('Freight Car 2')
	--now if the list is empty the first node will be the head and the tail until more nodes are added

	--Now we can perform some methods on this code
	--train.traverse() will print the list in order from head to tail.
	--train.append('') will add whatever you want to the end of the list
	**Example: train.append('Caboose') would add Caboose after Freight Car 2.
	--when we append a node, it doesn't matter how long the list is it's always constant time because we have the tail reference built in

**We may also want to Remove a Node (by value)
	--What would need to be changed to remove?
	--ant --bee --caterpillar	
**This code is kind of complex since we need to handle things like:
	1.) removing only item in linked list
		--update head and tail to null
	2.) removing first item
		--update the head
	3.) removing last item
		--update the tail
**A rundown of how removing from a linked list works
	1.) find the element before what we want to remove
	2.) then remove it by finding the element after it
	3.) then connecting the element from before to the element after
	**Visual Example:
	head => [66][.] => [28][.] => [76][.] => [20][.] => [4][.] => [38][.] <= tail
		--let's say we want to remove 20	
		--we need go to 76 (the element before 20)
		--then go to 4 (the element after 20)
		--then connect 76 to 4 (connecting the element before 20 to the element after 20)
		--this will severe the connection to 20 and remove it from the list

			11.4.13
			Linked List Big O
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64508

**Runtime of Linked Lists
	1.) going to "next" item
		--O(1) Constant Time
	2.) Going to item by arbitrary index (give me 7th or 100th item in the list)
		--O(n) Linear Time
	3.) Searching for value
		--O(n) Linear Time
	4.) General insertion or deletion (at 25th position or somewhere in the middle of the list)
		--O(n) Linear Time
	5.) Adding to the start
		--O(1) Constant Time
	6.) Appending to end
		--O(1) Constant Time if we know the tail
		--O(n) Linear Time if we don't know the tail
	7.) Deleting at start
		--O(1) Constant Time
	8.) Removing from end
		--O(n) Linear time
		--this is because the code has no way of knowing where the end is unless it traverses the entire list
**How do these compare to an array?
	1.) Going to item by arbitrary index (give me 7th or 100th item in the list)
		--Constant Time
	2.) Searching for value
		--Linear Time
		--because you have to look at every value
	3.) General insertion or deletion (at 25th position or somewhere in the middle of the list)
		--Linear Time
		--because all values have to be shifted
	4.) Adding to the start
		--Linear Time
		--because all values have to be shifted
	5.) Appending to end
		--Constant Time
	6.) Deleting at start
		--Linear Time
		--because all values have to be shifted
	7.) Removing from end
		--Constant Time

			11.4.14
			Doubly-Linked Lists
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64508
			
**Doubly-Linked Lists
	--Singly-linked lists really extend our ability to collect and organize data, but they suffer from a crucial limitation
		--we can only ever move in on e direction through the list
	--Consider the implication that would have for trying to delete a node
	--A doubly-linked list allows us to move forward and backward through the list, all by simply adding on extra pointer to our STRUCT (Node) 	definition
		--doubly-linked lists take up more bytes of memory

**Doubly-Linked Lists Example Code:
	typedef struct dllist{
	VALUE val;
	struct dllist* prev;
	struct dllist* next;
	}
	dllnode;

**Review of operations you can do with singly-linked lists from 11.4.8
	1.) Create a linked list when it doesn't already exist.
	2.) Search through a linked list to find an element.
	3.) Insert a new node into the linked list.
		--different in doubly-linked list 
	4.) Delete single element from a linked list
		--different in doubly-linked list
	5.) Delete an entire linked list.

**Inserting a new node into D-L List
	-- dllnode* insert(dllnode* head, VALUE val);
**Steps involved:
	1.) Dynamically allocate space for a new dllnode
	2.) Check to make sure we didn't run out of memory
	3.) Populate and insert the node at the beginning of the linked list.
	4.) Fix the PREV pointer of the old head of the linked list.
		--extra thing to do compared to Singly-Linked List
	5.) return a pointer to the new head of the linked list.
	**Visual Example:
		-- list = insert(list, 12); //insert 12 into the list
		[NULL[15][.] <-> [NULL][9][.] <-> [NULL][13][.] <-> [.][10][NULL]
		-- [] //create empty node
		-- new -> [12] //put 12 inside the empty node
			--remember, we can never break the chain when rearranging the pointers
			--even if we need to have redundant pointers temporarily, that's okay
		-- new -> [NULL][12][.] -> [NULL][15][.] //add null and point null 12 to null 15 
		-- new -> [NULL][12][.] <-> [NULL][15][.] //point 15 back to 12
		-- new -> head -> [NULL][12][.] <-> [NULL][15][.] <-> [NULL][9][.] <-> [NULL][13][.] <-> [.][10][NULL //move the head from 15 to 12
			 
**Deleting a node from a linked list
	-- void delete(dllnode* target);
**Steps involved
	1.) Fix the pointers of the surrounding nodes to "skip over" target
	2.) Free target
	**Visual Example:
	-- delete(x); (general case when deleting any node from middle of list (with legit prev and next pointers.)
		head -> [NULL][12][.] <-> [NULL][15][.] <-> [NULL][9][.] <-> x -> [NULL][13][.] <-> [.][10][NULL] //x is being pointed at only 
		[NULL][13][.]
	--next we change next pointer of 9 to point to 10
	--then we change prev pointer of 10 to point to 9
		head -> [NULL][12][.] <-> [NULL][15][.] <-> [NULL][9][.] <-> [.][10][NULL] //this is the result
	--we kept integrity of the list by moving the next pointer of 9 and the previous pointer of 10 by making them pointer at each other
**Doubly-Linked Lists
	--Both singly and doubly linked lists support extremely efficient insertion and deletion of elements
		--these operations can be done in constant time
		--it always takes 3 operations to delete a node in doubly linked lists
		--3 or 4 operations to insert (at the beginning of the list)
	--What's the downside?
		--Remember how we had to find an element? 
		--We've lost the ability to randomly-access list elements
		--Accessing a desired element may now take linear time

			11.4.15
			Doubly Linked Lists Continued
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64508

**Singly-Linked Lists
	--every node has a pointer to the next node
**Double-Linked Lists
	--each node has 2 pointers.
		--1 from previous pointer and 1 to next pointer
	--allows us to traverse backwards
	--makes insertion easier
	--makes deletion from end of list easier
	--downside is it's a little trickier 
		--you have to remember to update prev as well as next
		--also takes up more memory

			11.4.16
			Arrays Vs Linked Lists
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64496/64508

**Which is faster? Linked List or Array
**What's the difference between the two?
	--array storing several values in memory
		0[12][23]
		1[41][23]
		2[78][85]
		3[55][95]
		4[254][126]
	--linked lists work different
	--start at beginning which points to nothing
	--as we add things we allocate memory for it
		head -> [1][.] -> [2][.] -> [3][.] <- tail
	--we can change, add and remove things from linked lists pretty easily
**Have structure with 2 things (integer p and integer q)
	--consider operation where we go through all of the elements and sum them up in an array
	--consider operation where we go through all of the elements and sum them up in a linked list
		--in both arrays and linked lists you have to visit every element

**Visual Example in C (computer language):
Ex.1 (Linked List)	struct item{
    		int p;
    		int q;
    		// char foreName[64];
   		// char surName[64];
    		struct item *next;
		};

Ex.2 (Array)	struct arrayItem{
    	int p;
    	int q;
    	// char foreName[64];
    	// char surName[64];
	};
	--the only difference between these two examples is linked list has one extra item (next pointer to next thing)
	--everything else is identical

**We can run each function 100 times (the function adds all the numbers in the data structure) and see which is faster
**Example in language of C for array:

	int sumArray(struct arrayItem p[], int num){
    int sum = 0, i; //set variable to 0 which is our sum
    for(i = 0; i <num; i++){ //variable i is index through the array
        sume = sum + p[i].p; //sum is equal sum + value of ith element in the array stored in the p postion
    }
    return sum;
}

**Example in language of C for linked list:

	int sumList(struct item *p){
    int sum = 0
    while (p != NULL){	//while we haven't reached the end of the list // p is first thing in the linked list
        sume = sum + p->p; //
        p = p->next; 	//set p to point to the next thing (follow link to next element in linked list)
    }
    return sum
}

**So how long does each iteration take on an Atari?
	--Linked List with 125,000 elements
		--average clock ticks: 166
	--Array with 125,000 elements (smallest index to largest index)
		--average clock ticks: 178.5
	--Array with 125,000 elements (largest to smallest index)
		--Average Clock Ticks: 114
**How long does it take on an iMac
	--Linked List with 125,000 elements
		--average clock ticks: 209.54
	--Array with 125,000 elements (forward)
		--Average clock ticks: 44
	--Array with 125,000 elements (backward)
		--Average Clock Ticks: 47
**How long on raspberry pi?
	----Linked List with 125,000 elements
		--average clock ticks: 1859
	--Array with 125,000 elements (forward)
		--Average clock ticks: 966
	--Array with 125,000 elements (backward)
		--Average Clock Ticks: 1020
**Conclusions
	--Array is technically slower than a linked list on Atari
	--about 10% slower than a linked list
	--an array backwards is faster
	--an array is faster than a linked list on iMac
	--about 400% faster

**Conclusions -- going deeper: why is an array faster when you run through it from largest index to smallest index?
	--We wrote the programs in a high level language (C)
	--they got compiled down to instructions that Atari can execute
	--these instructions favor going from largest to smallest index
**What about going backwards on the iMac?
	--it's about the same as going forward

**Visual Conclusion
	--chart below shows clock ticks on different machines
		array		linked list		reverse array
Atari		179		166			115
iMac		43		209			47
pi		966		1859			1020

**Let's focus on Atari and pi
	1.) Atari
		--cpu has to access memory for everything
		--everything cpu needs to fetch has to come from memory
		--takes the same amount of time no matter what you're fetching
		--memory is faster than CPU
	2.) pi
		-- memory -> data cash -> instruction cash -> CPU
		--CPU is faster than the memory
		--when CPU asks for something it has to wait or memory to find it
		--array runs faster on pi because all instructions have "fast lane" from cahce
		--one curcial difference with linked lists
			--you have to make 1 memory access for date value and another for address of the next element

**So what's the answer? Are arrays or linked lists faster?
	--it depends on the CPU of the machine you're using
	--it depends on how the test is set up
	--basically you can't know for sure until you run the tests


		



	

















