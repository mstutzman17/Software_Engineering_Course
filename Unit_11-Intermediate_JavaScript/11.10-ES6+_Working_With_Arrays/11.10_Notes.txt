Notes for Unit 11 Subunit 10

			11.10.1
			Callback Functions Revisited
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582

**Subset of built array methods that accept callbacks as arguments
	--array docs on MDN
	--there are tons of array methods
	--one such method is forEach method which accepts a callback
	--another is reduce

**Let's talk about functions as values in JS and how we can pass functions around
	--we have multiple ways of defining a function
	**Examples
1.) Defining a funciton

function holler() {
    console.log("Hey you!")
}

2.) Annonymous Function Expression
	--basically a function stored in a variable

const whisper = function() {
    console.log("pssst.... i have a secret")
}
	--let's rep here for second
	--to execute we can call whisper in the console
	--if we do that, we would get "pssst.... i have a secret" printed to the console
	--so this is where we will start into the meat of this video which is passing functions around
	**Example:

function add(x,y){
    return x + y;
}

function subtract(x,y){
    return x - y;
}

function multiply(x,y){
    return x * y;
}

function divide(x,y){
    return x / y;
}
	--above, we have 4 simple math functions
	--like a number or string, functions are values
	--we could even put functions inside an array
	**Example:

const mathFuncs = [add, subtract, multiply, divide]
	--it's important to note that you don't add the parens when you put functions into an array
	--if you do you are trying to execute the function right away
	--here we are just reference the value each function by putting the function name into the array
	--now let's say we wanted call one of these functions using the mathFuncs variable
	**Example:

mathFuncs[3](18,2)
	--here we are accessing index of 3.
	--in the mathFuncs array index of 3 references the divide function
	--so that is what function will be carried out

**Let's talk about callbacks (functions as arguments)
	--we've seen it before
	**Example:

const whisper = function() {
    console.log("pssst.... i have a secret")
}

setTimeout(whisper, 4000)
	--here we have set the first parameter to the name of the function
	--the second parameter is the amount of time to wait before the function passed an argument is carried out
	--it's important to note that we are not calling the function whisper.
	--the setTimeout method is calling the function
	--so we do not need the parens after the function name
**The question is how do we write our own functions that do this?
	--it's pretty straightforward
	--we treat them like any other argument
	**Example:

function doMath(a,b,mathFunc){
    return mathFunc(a,b)
}
	--here we have a function called doMath
	--the first two parameters are set as a,b but you can call them whatever you want
	--the third parameter is going to call a function (again the name can be whatever you want)
	--in the body of the function we are returning whatever math function we decided on and whatever numbers we decided on.
	**Example:

function doMath(a,b,mathFunc){
    return mathFunc(a,b)
}

console.log(doMath(17,27,add))
	--here we have successfully used a function as an argument

**We can also pass in an anonymous function
	**Example:

doMath(7,7, function(a,b){
    console.log(`Answer: ${a ** b}`);
})
	--as our third parameter here, instead of callback a function, we written an anonymous function that only exists in this block of code
	--in the example above we used an inline anonymous function

**What if we used the mathFuncs array and defined a function called do all math
	--this would accept 2 numbers and the mathFuncs array as 
	--we want it to call each function in the array and list the answers
	**Example:

function doAllMath(a,b, mathFuncs){
    for(let func of mathFuncs){
        console.log(`Answer: ${func(a,b)}`)
    }
}

console.log(doAllMath(7, 7, mathFuncs))
	--the doAllMath function accepts 3 parameters
	--we used a for loop to iterate over each value of the mathFuncs array
	--after the for loop we console.log the result
	--and voila, we've used an array as an argument in a function

			11.10.3
			forEach
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582

**We're talking about array methods that expect a function as an argument
	1.) First up is the forEach method
		--it's the simpliest one
		--not most powerful, not most useful, just easiest to understand
**How does it work?
	--Loops through an array
	--runs a callback function for each value in the array and then returns undefined
	--forEach will always return undefined - no matter what
	**Example:

const colors = ['teal', 'cyan','peach','purple']

colors.forEach(function())
	--this is the setup
	--often you would write an inline function for the argument of the forEach method
	--however, you can also call an existing function
	**Example:

colors.forEach(console.log)
	--if we run this code, the console will return the following:

teal 0 >Array(4)
cyan 1 >Array(4)
peach 2 >Array(4)
purple 3 >Array(4)
	--we see here that each color from our colors array are being individually printed, along with it's index and the entire colors array
	--this gives us insight into how forEach works
	--every function we pass into forEach can take/return 3 arguments
	--in the colors example teal is the first argument, 0 is the second argument, and the entirety of the array is the third argument
	--most often we will only use 2 arguments (the value and the index)
	**Example:

colors.forEach(function(val){
    console.log(val.toUpperCase())
})
	--here we're accessing the colors array and printing the uppercase value (val) of each element to the console
	--we could also write the function separately and pass the name of the function in as a callback
	**Example:

const colors = ['teal', 'cyan','peach','purple']

function yellColors(val){
    console.log(val.toUpperCase())
}

colors.forEach(yellColors)
	--this would do the exact same thing as the prior example
	--we could also use the index if we wanted to
	**Example:

const colors = ['teal', 'cyan','peach','purple']

function yellColors(val, index){
    const caps = val.toUpperCase()
    console.log(`At index ${index}: ${caps}`)
}

colors.forEach(yellColors)
	--here we have value AND index as parameters
	--we then logged a template literal to the console where we called our index and our value
**AGAIN
	--Most often we would use an inline function like our first example
	--but we could also use a callback function
	--first parameter is value of the element
	--second parameter is the index of the element
	--third value is the array(not commonly used)

**Let's try another example:
	--we have an array of prices
const prices = [30.99, 19.99, 2.5,99.0]
	--we could use forEach to sum up all of these prices
	--there are other ways to do it, but let's try forEach
	--we need to create a variable using let
	**Example:

const prices = [30.99, 19.99, 2.5,99.0]
let total = 0;
prices.forEach(function(price){
    total += price;
})
console.log(total)
	--here we forEach calls our anonymous function and passes in the first value of the prices array
	--total += price is taking the first element and adding it into the total variable
	--then the process repeates until the end of the array
	--and after that process is complete, the total variable is printed to the console
**The thought may occur that we could do this with any old regular loop
	--what about a for of loop
	--we actually could do this
	**Example:

const prices = [30.99, 19.99, 2.5,99.0]
let total = 0;
for( let price of prices){
    total += price;
}
console.log(total)
	--this would do the exact same thing
	--in fact it's cleaner and easier to understand
	--but the reason forEach exists is because for of loops are a more recent addition to JS
	--the difference between the 2 is that we don't use a callback or function in the for of loop
	--so it we had function that we wanted to use a for of loop for we would have to write the loop and call the function within the loop
	--with forEach we can just call the name of the function and be done with it
	--in the past forEach was easier than a regular for loop
	**Example:

const prices = [30.99, 19.99, 2.5,99.0]
let total = 0
for (let i = 0; i < prices.lenght; i++){
    total += prices[i];
}

			11.10.4
			Writing forEach
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582

**For this section of the unit we will be doing a practice exercise with forEach
**We are attempting to create a function that does the same thing the forEach method does
**Here are the requirements for the function
	1.) Loops through an array
	2.) Runs callback function on each value of array
	3.) Returns undefined

**My Attempt:

const myForEach = [4,5,6]

myForEach.forEach(function (value){
    console.log(value)
})

**The right way

function forEach(arr, callback){
    for(let i = 0; i < arr.length; i++){
        callback(arr[i])
    }
}

forEach(prices, function(price){
    console.log(price)
});

**Notes on my attempts
	--in my attempt I didn't follow the directions that were given.
	--I did successfully implement the forEach method while calling an inline, anonymous function
	--but I was supposed to create a function that loops through an array, runs a callback function and returns undefined
**Notes on the right way:
	--the version that I coded along with (the right way) does things, well what do you know, the right way
	--first there is a function called forEach with 2 parameters (arr, callback)
	--the function loops through each value of an array using a for loop
	--then we callback the arr at [i]

**Important to understand how forEach works**
	--it passes in the index as argument to callback second argument
	--in other words, the first parameter of forEach points to the value of the array, the second points to the index of that value, and third points to 	the array in it's entirety
	--that means we could also print the index of each price in the prices array
	--in order to do that, though, we have to pass through the index in our function
	--the only thing you need to change is adding that to the callback list in the function
	--and adding it to console.log list as well
	--the hardest part here is the callback
	--we're setting callback as a parameter and then calling it the same function
	--the thing, the callback function is not defined until we call our forEach function
	--then the callback function is an inline anonymous function and the second argument of the forEach function
**Pretty confusing, but we'll just build from here

			11.10.7
			map
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64588

****Array Methods Continued
	1.) First up is the forEach method
	2.) the map method
		--a very useful method for arrays in JS

**Goals with map
	1.) Understand wha map does
	2.) Be able to write our own version of map
**What is map?
	--creates a new empty array
	--iterates through an array
	--runs callback function for each value in array
	--returns new array
	--map always returns a new array of the same length as the original array
	**Example:

const numbers = [21, 37, 64, 99, 142]
numbers.map(function(num){
    return num * -1;
})
	--just like for each, the first argument of the callback is the value of each individual element in the array
	--in the above example we will get a new array.
	--if we call the original numbers array, it will remain the same
	--this is because map does not mutate or change the original array
	--for that reason we need to use a function expression
	**Example:

const numbers = [21, 37, 64, 99, 142]
const negatives = numbers.map(function(num){
    return ( num * -1);
})
	--what we're doing is saving the map method that's being used on the numbers array into a new variable
	--we do this because, again, map does not mutate the original array
**When working with map...
	--you need to make sure the callback function returns something
	**Example:

const doubles = numbers.map(function(num){
    console.log(num * 2)
})
	--we will not get an array returned, because the map method expects a return value in order to build the new array
	--what does console.log return?
	--if we look at the doubles variable we just defined we would get an array of undefined the same length as the numbers array

**Let's get more complicated
	**Example:

const toDos = [
    {
        id: 1,
        text: 'walk the dog',
        priority: 'high'
    },
    {
        id: 2,
        text: 'walk the chickens',
        priority: 'medium'
    },
    {
        id: 3,
        text: 'feed the cats',
        priority: 'low'
    },
    {
        id: 1,
        text: 'put out fire in garage',
        priority: 'very high'
    }
]
	--let's say we want to create an array with just the text property in each object
	--this a common use case of the map method 
		--when we have a more complicated data structure and want to extract specific pieces, but not all pieces of that data
	--how would handle this?
	**Example:

const toDoText = toDos.map(function (todo) {
    return todo.text;
})
	--map is iterating through each object of the array.
	--each object is considered 1 element
	--when it iterates through an object it is pulling out the value of the text property and putting it into a new array
	--it continues till the end and then we get a new array
	--in the new array we will have 4 elements
	--each element will be the value of the text property from the original objects in the original array

**Let's move on to a more realistic example:
	--we have a website that has 4 links
	--each link is to a different website
	--we want to extract the href from the link tag in the html
	--how the heck would we do that?
	--well, we use map and something called query selector
	**Example:
const links = document.querySelectorAll('a');
	--this would give us a NodeList which means that our array methods won't work on it
	--we can change it into an array though
	**Example: 
Array.from(links)
	--this gives us an actual array
	--now we connect it all
	**Example

const links = Array.from(document.querySelectorAll('a'));
const urls = links.map(function (a){
    return a.href;
})
	--now if we call the urls variable we will get an array 4 elements
	--each element is 1 href

**The return statement of a.href is different
	--if we type Array.from(links)[0] into the console it would return the first href in our ul from our html document
	--it does this because we have transformed the ul in our html document into an array us the Array.from method
	--we've also linked the each li from the ul to our JS by using the document.querySelectorAll method
	--so now each li in our ul from our html is an elment in our array in our JS
	--that means that Array.from(links)[0] is a reference to the first li in our ul
	--Array.from(links)[1] is a reference to the second li and so on and so forth

			11.10.8
			Writing map
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64588

**Same format as the writing forEach
	--just like forEach, our function will work slightly differently
	1.) We need to pass in the array
	2.) Then we would pass in our callback
	3.) The callback will return 3 different arguments if we want to accurately recreate how map works
	**Example:

myMap([1,2,3], function(val){
    return val * 3;
})
	--even though there is only one parameter, this should return a new array [3,6,9]

**Requirements
	1.) Define a function
	2.) The function needs 2 arguments (array, callback)
	3.) Make new empty array
	4.) Loop over array that is passed in
	5.) call callback once per item in the array
	6.) take return value and push it onto array
	7.) return that array at the very end

My Attempt:

function myMap(array, callback){
    const emptyArray = [];
    for(let i = 0; i < array.length; i++){
        emptyArray.push(callback(array[i]))
    }
} 

const newToDos = myMap(toDos, function(toDos) {
    return toDos
})
	--I know that this is not correct
	--I am a lot closer than I was last time, though

The Right Way:

1. function myMap(array, callback) {
2.    const mappedArray = []
3.     for (let i = 0; i < array.length; i++){
4.        mappedArray.push(callback(arr[i]))
5.    }
6.    return mappedArray;
7. }
8.
9. const priorityMap = myMap(toDos, function (priority){
10.   return priority.priority;
11. })
	--line 2 we start with a new, empty array
	--line 3 then we loop over the array that we want to call
	--line 4 we call the callback function AND we push that onto the mappedArray
	--line 6 we return the mapped array
	--line 9 we save our myMap function into a new variable called priorityMap
		--the variable executes the myMap function on the toDos array.
		--the parameter of the function is one element of the array
	--line 10 we return the element of the array that we want
		--in this case we are extracting the priority property from each object in the toDos array

**IMPORTANT TO REMEMBER
	--the map method always returns 3 arguments
		1.) The value of the element
		2.) The index of the element
		3.) The entire array
	--in our above example we could add to line 4
		--mappedArray.push(callback(array[i], i, arr))
	**Example:

1. function myMap(array, callback) {
2.    const mappedArray = []
3.    for (let i = 0; i < array.length; i++){
4.        const val = callback(array[i], i, arr)
5.        mappedArray.push(val);
6.    }
7.    return mappedArray;
8.}
9. 
10.  const repeatedLetters = myMap(['a', 'b', 'c', 'd', 'e', ], function(str, idx){
11.    return str.repeat(idx);
12. }) 

	--line 4 we created a variable to store our values for our parameters in
	--line 5 we're pushing those values into the new array
	--line 10 we call our function on a new array (the one that's inline)
		--we have an inline function that accepts 2 parameters
		--we save the function to the variable
	--line 11 we're using string.repeat method
		--this allows us to repeat a string ("lol".repeat(4) would b "lollollollol" 
		--we repeat each string idx times.
		--this means that we are repeating each string based on the index of that string ('a' repeats 0 times, 'b' once, 'c' twice, and so on
		--we need a return otherwise we'll get a bunch of undefined

**Here's a couple scenarios where you would use map method
	--you want to "transform" an array into another array of the same length
		--you wanna take a piece of data for each element in an existing array
		--and then you want to doing something with that element (double it, add, subtract, extract)
		--extracting is most common
		--like you want to extract the price from a list of items or something along those lines
	--you do not want to overwrite an existing array and instead return a new copy

**Review
	--map creates new array
	--map runs a callback on each value and pushes the result of each callback in the new array

***It is the difference between this:


const numbers = [21, 37, 64, 99, 142]
const negatives = numbers.map(function(num){
    return ( num * -1);
})

***And this:

function myMap(array, callback) {
    const mappedArray = []
    for (let i = 0; i < array.length; i++){
        const val = callback(array[i], i, array)
        mappedArray.push(val);
    }
    return mappedArray;
}

const repeatedLetters = myMap(['a', 'b', 'c', 'd', 'e', ], function(str, idx){
    return str.repeat(idx);
})


			11.10.11
			filter
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64592

****Array Methods Continued
	1.) forEach method
	2.) map method
	3.) filter method
		--instead of mapping each element it creates new array where we filter based on a condition
**Goals
	1.) Understand what filter does
	2.) Write your own filter function

**How does filter work?
	--creates new array
	--Loops through an array
	--runs a callback function on each value in the array
	--if callback is true value is pushed to new array
	--if callback function false, value will not be included in the new array
	--result of the callback will always be evaluated into a Boolean

Let's see an example of the filter method
	**Example:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'pseudopseudohypoparatahyroidism',
    'immunoelectrophoretically',
    'unimaginatively'
]

const longWords = words.filter(function (word){
    return word.length >= 20;
})
	--this will create an array with words that have 20 or more characters
	--it is referencing the words array above
	--so if we call longWords, it will return an array of 3 items with 20 or more letters
	--we can also create a new array for words that start with u or c
	**Example:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'pseudopseudohypoparatahyroidism',
    'immunoelectrophoretically',
    'unimaginatively'
]

const randomWords = words.filter(function (w){
    return w[0] === 'u' || w[0] === 'c'
})
	--this creates an array with words that start with the letter 'u' or 'c'

**We can get even fancier
	--we want to create a new array with words that do not have vowels in them
	**Example:

const containsVowel = function(word){
    for (let char of word){
        if(isVowel(char)) return true;
    }
    return false;
}

const randomWords = words.filter(function (w){
    return w[0] === 'u' || w[0] === 'c'
})

const vowelWords = words.filter(containsVowel)
const noVowels = words.filter(function(word){
    return !containsVowel(word)
})
	--we create variable called isVowel
	--the variable has function that accepts a character
	--returns true or false if character is or isn't a vowel
	--then we make a string of the vowels and check if the any of them are in the word using indexOf
	--if it's false it will return -1, if true a positive 1 is returned
	--we set this 'aeiou'.indexOf(char) != -1 so that we can avoid the vowels
	--then we make a variable called containsVowel with a function that accepts a word
	--we us a for of loop to determine whether each letter in the word is a vowel or not
	--we do this by using an if statement on the isVowel function
	--so if the word contains a vowel the if statement returns true
	--if we make it through every character of a word and there aren't any vowels, that statement will return false
	--then we can pass in the containsVowel function saved in a variable to the noVowels variable
	--if it returns true, the word will be added to the filtered array
	--so it doesn't work how we want it to
	--now we need to create another variable with a custom function
	--this function will return the opposite of containsVowel
	--so now if we filter will create an array with words that DO NOT contain vowels

			11.10.12
			map and filter
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64592

**Another example of using filter with some dom elements
	**Example:

const allCheckboxes = document.querySelectorAll('input[type="checkbox"]')
	--so we start by selecting all of the input type='checkbox' list items from our html doc
	--we can then filter only the checked checkboxes
	--the only problem once again is that allCheckboxes is not an array
	--so we have to turn it into one
	**Example:

Array.from(allCheckboxes)
	--now we have an array called allCheckboxes
	--we can then use the 'checked' property to see if which elements are and are not checked
	**Example:

Array.from(allCheckboxes)[0].checked
	--this would return true because the [0] (first element) is a checked checkbox
	--Array.from(allCheckboxes)[1].checked would return false because the second element (index of 1) is not a checked checkbox
	--now we can move on and use the filter method to create an array with only checked inputs
	**Example:

const allCheckboxes = document.querySelectorAll('input[type="checkbox"]')

const checked = Array.from(allCheckboxes).filter(function (box){
    return box.checked;
})
	--now we have array with all the inputs that are checked on the todo list
	--what if we wanted to know which things are done
	--we could just call checked.lenght and would tell us how many tasks we completed
	--but we want to know how many tasks AND which tasks were completed
	--we could use map to accomplish
	**Example

const completedItems = checked.map(function (checkbox){
    return checkbox.parentElement.innerText;
})
	--we have an array of checked boxes
	--for each one we create new array where we access parent li element and access the inner text for that li element
	--then we return that text as an element in the new array that the map method is creating
	--so now we have a new array that tells us which items we completed that day
	--we could cut down some steps in this process
	**Example:

function extractCompletedTodos(){
    const allCheckboxes = document.querySelectorAll('input[type="checkbox"]')
    return Array.from(allCheckboxes).filter(function (box){
        return box.checked;
    })
    .map(function (checkbox){
        return checkbox.parentElement.innerText;
    })
}
	--now we've combined each step of the process into one function
	--in the function we have a return statement that runs the .filter and .map methods to create a lovely new array

			11.10.13
			Writing filter
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

**Now we want to write our own code that will behave like the filter method would
	--our version needs to accept an array first myFilter(arr, callback)

**My Attempt:

I honestly can't manage an a well thought out attempt right now. So I will rely on the "Right Way" to teach and guide me.

**The Right Way:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'cysts',
    'pseudopseudohypoparatahyroidism',
    'unimaginatively'
]

1. function myFilter(arr, callback){
2.    const filteredArray=[]
3.    for (let i = 0; i < arr.length; i++){
4.        if(callback(arr[i], i, arr)){
5.            filteredArray.push(arr[i])
6        }
7    }
8    return filteredArray;
9 }

10 const shortWords = myFilter(words, function(word){
11    return word.length<=10;
12 })
	--line 1 we define our myFilter function
	--it accepts an array and a callback function(arr, callback)
	--line 2 we create a filterArray variable that we can push our elements into
	--line 3 we need a for loop to iterate through the array that we choose
	--line 4 we need an if statement
	--the if statement calls the callback on the index of i, the index of the array and the arr itself
	--line 5 if everything in the callback is true we push the arr[i] to the filteredArray
	--if not, we move on
	--line 8 at the end of the function we are returning the filtered array which will have all the correct information
	--line 10 we create a variable called shortwords
	--line 10 we set the variable equal to our version of myFilter (the myFilter function)
	--line 10 when we call this function we reference the words array
	--line 10 then we write an inline function that determines our condition 
	--line 11 our condition is words that are 10 or less letters long
	--if we call the shortWords variable we get an array that has pulled out any word that is 10 or less letters from the words array

**We could also use the index that the filter method returns
	--let's filter our everyother word based on the index
	--so we're making a new array with every even index
	**Example:

const evenIndex = myFilter(words, function(word, i){
    return i % 2 === 0
})
	--now every other word in the words array is put into a new array
	--we did this by using the index parameter that is also native to the filter function (just like map and forEach)

			11.10.15
			some and every Handout
			https://lessons.springboard.com/some-every-fb449e666cb74b0ca7630f8d102c1465

**This handout includes goals for the some and every methods
**Goals:
	1.) Understand what some and every do
	2.) Write your own version of some and every
**The handout also includes the definition of the some method and the definition of the every method
**This handout also includes examples of how to use each method
	--all of this information will be covered in the following videos

			11.10.16
			some and every
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

****Array Methods Continued
	1.) forEach method
	2.) map method
	3.) filter method
	4.) some and every
		--these methods are similar which is why they will be covered together

**Goals
	1.) Understand how each method works
	2.) Write our own version of each method

**Let's start with some
	--both some and every return true or false
	--iterates through an array
	--runs a callback on every element in an array
	--if callback returns true for at least one value, the whole method returns true
	--if the callback never returns true, then the method returns false
**Let's try it out
	**Example:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'cysts',
    'pseudopseudohypoparatahyroidism',
    'unimaginatively'
]

const longWords = words.some(function(word){
    return word.length > 60;
})
	--we are checking to see if any of the words in the words array are longer than 60 characters
	--there are none, so the variable we put this in returns false
	--if we had used 25 instead of 60, the variable longWords would have returned true
	--we can also use this to check if a sequence of letters is in a word
	**Example:

const wordsWithThyroid = words.some(function(word){
    return word.indexOf('thyroid') !== -1;
})
	--we use indexOf to check if the specified string exists in any of the strings within the words array
**Let's look at the every method
	--this does the opposite of some
	--if one element of an array does not meet criteria, it returns false
	--if every element meets the specified criteria, it returns true
	**Example:

const words = [
    'immunoelectrophoretically',
    'rotavator',
    'tsktsk',
    'psychophysicotherapeutics',
    'squirrelled',
    'crypt',
    'uncopyrightable',
    'cysts',
    'pseudopseudohypoparatathyroidism',
    'unimaginatively'
]

words.every(function(w){
    return w.length >= 5;
})
	--if every word in the words array is at least 5 characters, this will return true.
	--otherwise it would return false
	--let's check to see if every element in an array is a string
	**Example:

function allStrings(arr){
    return arr.every(function(el){
        typeof el === string
    })
}
	--here we've created a function to check whether each element is a string or not
	--we 'baked in' the every method so that we would get a Boolean returned (true or false)
	--we also use the typeof operator which is a little different
		--it's not camelCase
		--it returns in a string the data type that is being used in any specific set of code
		--typeof 4 would return "number" typeof 'amen' would return 'string'
	--so in our function we are iterating through each element in an array
**Let's look at a more practical example
	**Example:

const btn = document.querySelector('button');
btn.addEventListener('click', function (e){
    const checkboxes = document.querySelectorAll('input[type="checkbox"]')
    const allChecked = Array.from(checkboxes).every(function(checkbox){
        return checkbox.checked
    })
    console.log(allChecked)
})
	--what this code does is check to see how many boxes have been checked
	--the boxes that are not selected end up in a Node like this: NodeList(4) [input, input, input, input]
	--you can tell that 4 of the boxes have not been checked
	--we start by selecting the button
	--then we add an event listener for when the user clicks
	--then we want to select all of the checkboxes
	--then we have to convert the NodeList into an array so that we can use the some or every methods
	--we save the Array.from into a variable
	--now if we click on the submit button it will return false if not every box is checked
	--if every box IS checked, it will return true
	--we can add an alert to let the user know that they have to check all the boxes to continue
	**Example:

const btn = document.querySelector('button');
btn.addEventListener('click', function (e){
    const checkboxes = document.querySelectorAll('input[type="checkbox"]')
    const allChecked = Array.from(checkboxes).some(function(checkbox){
        return checkbox.checked
    })
    if(!allChecked) alert("Please agree to all terms before you continue.")
})

			11.10.17
			Writing some and every
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

**Here we will try to write our own code to mimic the some and every array methods
**Writing some
	--iterates through an array
	--runs a callback on each value in the array
	--if callback returns true for at least on single value, return true
	--if ALL values return false, return false

**My Attempt

const mySome = function(arr, callback){
    for(let i = 0; i <= arr.length; i++){
        if (callback(arr[i])){
            return true
        }
        return false;
        }
        
}

**The Right Way:

const mySome = function(arr, callback){
    for(let i = 0; i <= arr.length; i++){
        if (callback(arr[i], i, arr)) return true
    }
    return false;
}

mySome(words, function (word){
    return word.length >= 5 ;
})
	--my way and the right way were pretty much identical
	--however, I did forget how to implement my version of the method
	--other than that, it was pretty straight forward

**Writing every
	--iterates through an array
	--runs callback on each value in the array
	--if the callback ever returns all false, return true
	--if the callback returns even one element differently, return false

**My Attempt

const myEvery = function(arr, callback){
    for(let i = 0; i <= arr.length; i++){
        if (callback(arr[i], i, arr)) return false
    }
    return true;
}
	--my thought was that I would just have to switch the terms true/false
	--this was only a part of it, though


**The Right Way

const myEvery = function(arr, callback){
    for(let i = 0; i <= arr.length; i++){
        if (!callback(arr[i], i, arr)) return false
    }
    return true;
}

myEvery(words, function(word){
    return typeof word === 'string'
})
	--the only things we did is change the name of the function (obvious)
	--and then change the if statement by adding if NOT callback...
	--this will then act like the very method for arrays

			11.10.18
			find and findIndex Handout
			https://lessons.springboard.com/find-findIndex-e77d1e4e9d1241b2a10ae13e79a6a0cd

**This handout lists some goals for the find and findindex methods
	1.) Understand what find and finIndex do
	2.) Write your own version of find and findIndex

**This handout also lists the following about find
	--how this method works
	--how to use it in a function
	--WHEN to use it
**This handout also lists the following about findIndex
	--it defines the method/explains how it works
	--how to use findIndex in a function
	--WHEN to use findIndex

			11.10.19
			find and findIndex
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

****Array Methods Continued
	1.) forEach method
	2.) map method
	3.) filter method
	4.) some and every
	5.) find and findIndex

**Goals of find and findIndex
	1.) Understand how they work
	2.) Write our own versions of each method

**How does find work?
	--iterates through an array
	--runs callback on each value in the array
	--if callback returns true at any point, return the value in the array that we're iterating over
		--this only returns the first match
	--otherwise, return undefined
	**Example:

const scores = [
    0, 0, 0, 0, 0, 0, 0, 0,
    55, 59, 69, 73, 73, 75, 79, 83, 88, 91, 93
]

scores.find(function(score){
    return score >= 75
})
	--when we run this code it will return the number 75 to us
	--75 is the first time that our callback is true
	--the method does not even continue running after it finds something fulfills the condition we set in the callback\
	--if we were to set our condition to be a score above 100, it would return undefined
	--let's try something more complex
	**Example:

scores.find(function(score){
    return score % 2 === 0
})
	--this will check for the first even number
	--rather, it will check for the first number with 0 as a remainder if it's divided by 2
	--0 passes that check
	--if we want to avoid the 0 we would add logic to the return line
	**Example:

scores.find(function(score){
    return score !== 0 && score % 2 === 0
})
	--now we have set 2 conditions that both need to be met
	--how would we do find all
	--there is no findAll method
	--but we can use the filter method to accomplish the same thing
	**Example:

const evenScores = wscores.filter(function(score){
    return score % 2 === 0
})
	--so filter acts as a sort of "findAll" method

**We also have findIndex
	--iterates through an array
	--runs callback on each value in the array
	--if callback returns true for any single value, return the INDEX of that value
	--unlike find, findIndex does not return the value
	--findIndex returns the index of the value that meets the condition we set in our callback
	**Example:

const firstEven = scores.findIndex(function(score){
    return score !== 0 && score % 2 === 0
})
	--this iterates through the scores array from earlier
	--it then returns the index of the first value that is not 0, but is even
	--we use findIndex when indexOf will not work
	--indexOf is great when you want the index of a specific value
	--we can't use indexOf to find even or odd or something more advanced
	--let's say we want an array split into 2 subarrays
	--we could use findIndex to help (assuming the array is sorted)
	**Example:

function partition (arr, pivot){
    const pivotIndex = arr.findIndex(function(element){
        return element > pivot
    })
    console.log(pivotIndex)
}
	--this tells us the index of where we will divide our array (the pivotIndex)
	--to do this we would have to plug in 2 arguments to our partition function
		--an array
		--and the number we want to pivot at
	--now we want to create 2 new arrays based off of pivotIndex
	--we can use splice to do this
	**Example:

function partition (arr, pivot){
    const pivotIndex = arr.findIndex(function(element){
        return element > pivot
    })
    const failing = arr.slice(0, pivotIndex);
    const passing = arr.slice(pivotIndex)
    return [`Failing: ${failing} Passing: ${passing}`]
}
	--here we created 2 variables to hold our pivot points
	--we return these 2 variables and the function works
	--now if let's say we call partition(scroes, 69) we woud
	--this would return 2 arrays.
		--the first labeled Failing: goes from 0 to 69
		--the second labeled Passing: goes from 70 to the end of the array

**Next we'll try recreating the find and findIndex methods on our own

			11.10.20
			Writing find and findIndex
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

**As before, I'll attempt this on my own first
**Here are the requirements

**Requirements for myFind
	--iterates through an array
	--runs a callback on each value of the array
	--if the callback returns true AT ANY POINT, return the value and stop iterating
	--otherwise, return undefined

**MY Attempt

function myFind(arr, callback){
    for(let i = 0; i <= arr.length; i++){
        if (callback(arr[i], i, arr))
            return arr[i]
    }
    return undefined
}

myFind(scores, function (score){
    return score === 88;
})

*The Right Way

function myFind2(arr, callback){
    for(let i = 0; i < arr.length; i++){
        if (callback(arr[i], i, arr) === true) return arr[i]
    }
}
	--the logic for my attempt works just fine!
	--we could make my attempt more succinct and direct
	--the other thing that is wrong with my attempt is that I stat i <= arr.length
		--this is wrong because it iterates outside the parameters of the array, which could cause unwanted behavior
	--second, we don't need to return undefined, because if no value is found in a function it automatically returns undefinded

**Requirements for myFindIndex
	--iterates through an array
	--runs a callback on each value of the array
	--if the callback returns true AT ANY POINT, return the index of the value and stop iterating
	--otherwise, return -1
	**NOTE ABOUT findIndex: if it never finds what we're looking for we get -1
		--the same is true when we try to find "abc".indexOf('z')
		--z does not exist in the string we called, so it returns -1
		--because the value does not exist, there is no index to give
	--we need to remember this when attempting to recreate the findIndex method

**My Attempt
	
function myFindIndex(arr, callback){
    for(let i = 0; i < arr.length; i++){
        if (callback([i], i, arr) === true) return [i]
    }
    return -1
}

myFindIndex(scores, function(score){
    return score > 0
})

**The Right Way

function myFindIndex(arr, callback){
    for(let i = 0; i < arr.length; i++){
        if (callback(arr[i], i, arr) === true) return i
    }
    return -1
}

myFindIndex(scores, function(score){
    return score > 0
})
	--I did a couple thing wrong
	--first I did not run the callback on each value, just on the index of each value
	--second, i tried to return [i] when I could have simply said return i, because i is a parameter of my if statement
	--otherwise, I was pretty close

			11.22.10
			reduce Handout
			https://lessons.springboard.com/reduce-90df38e5a5d744a5bf7176628220239e

**This handout out lists goals for the reduce method
	1.) Understand what reduce does
	2.) use reduce to create new data structures
**It also does the following:
	--explains how reduce works
	--gives examples of how to use reduce
	--explains when you should use reduce

			11.23.10
			reduce
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595


****Array Callback Methods Continued
	1.) forEach method
	2.) map method
	3.) filter method
	4.) some and every
	5.) find and findIndex
	6.) reduce
		--can be used in many different ways
		--not as straightforward as the other methods we've learned

**Goals for reduce
	1.) Understand how it works
	2.) Use reduce to create new data structures
	3.) Create our own simple version of the reduce method

**What does the name reduce even mean?
	--the other array method names are meaningful
	--reduce is a little unclear judging by just it's name
**So what does reduce actually do?
	--it takes an array of elements and reduce them to a single value
	--like summing every element
	--or creating a new data structure based off an array
	--we could also find the min, max, or avg of a dataset
**Let's start by accomplishing some of these tasks without using reduce
	1.) Finding the sum of an array of numbers
	**Example:

const nums = [20, 30, 50, 12,-2,45,99,19,22,85]

let total = 0
for(let num of nums){
    total += num
}
console.log (total)
	2.) Finding the min/max value of an array
	**Example of min:

const nums = [20, 30, 50, 12,-2,45,99,19,22,85]

let min = nums[0]
for(let i = 1; i < nums.length; i++){
    if (nums[i] < min) min = min = nums [i]
}
console.log(min)
	**Example of max:

const nums = [20, 30, 50, 12,-2,45,99,19,22,85]


let max = nums[0]
for(let i = 1; i < nums.length; i++){
    if (nums[i] > max) max = nums [i]
}
console.log(max)
	3.) Moving the letters of a string into an array
	**Example:

const str="lollapalooza"
const charFreq  = {}
for(let char of str){
    if(charFreq[char]){
        charFreq[char] += 1;
    }
    else {
        charFreq[char] = 1
    }
}
	--in all 3 examples we are taking a group of values and reducing them into a single value
	--whether its sum or min. or creating a new array
	--all three of these are situations that we could use the array.reduce method

			11.24.10
			Using reduce
			https://www.springboard.com/workshops/software-engineering-career-track-f2c/learn#/curriculum/64582/64595

**Let's actually use the array.method reduce
	--in the previous video we showed how we could write our own code to do what the reduce method essentially does
**Reduce is a lot to take in
**So how does it work?
	--it accepts a callback function and an optional second parameter
	--iterates through the array that we're reducing
	--runs a callback on each value in the array
	--the callback has 2 parameters
		--the first parameter to the callback is either the first value (the accumulator(the value your reducing to (min/max, sum, etc))) 
		--second parameter is each value in the array
		--whatever is returned from callback becomes new value of accumulator
**Let's work on some examples:
	**Example One:

let evens = [2,4,6,8,10]
evens.reduce(function(accumulator, nextValue){
    return accumulator + nextValue
})
	--here accumulator is the "end product" or the thing we're reducing into (could be an array, object, etc)
	--the end value of accumulator is what is returned by reduce itself
	--first time through, the accumulator will be 2 (the first value of the array)
	--next value is 4 so we are returning 2 plus 4.
	--now the next time through the array, JS uses the sum of those values (6) as the new accumulator
	--so the next time through would be 6 plus 6
	--now the new accumulator is 12 and the next time through would be 12 plus 8
	--the new accumulator is now 20 and the next time through is 20 + 10
	--this all happens because of the return statement we used in the

	**Example Two:

const words = ['hello', 'i', 'love', 'you']
words.reduce(function(accum, nextWord){
    console.log(accum, nextWord)
})
	--here our result would look like this in the console
	hello i
	undefined 'love'
	undefined 'you'
	--this is because we don't return a value
	--so after console.log accum is set to whatever is returned in the callback, but it's not set to anything
	--let's actually return something
	**Example Two (continued):

const words = ['hello', 'i', 'love', 'you']
const results = words.reduce(function(accum, nextWord){
    console.log(accum, nextWord);
    return accum + nextWord;
})
	--we are concatenating these strings
	--let's try working with some numbers

	**Example Three:

const midtermScores = [ 88,70,93,94,64,62,56]
const minScore = midtermScores.reduce(function(min, nextScore){
    if(nextScore < min){
        return nextScore;
    }
    return min;
})
	--here we are checking for the lowest score in the array
	--the way reduce works here is it looks at the first value and next value
	--it returns the smaller of the two and then moves on and does the same thing
	--after it does that with each element of the array, it returns the lowest value
	--they are not named like it, but here the first parameter in callback is still "accumulator" and the second is the actual value of that element
	--we do not need to update the accumulator itself, we just need to return something and that value will be used as the new accumulator
	--let's rewrite this with a ternary operator
	**Example Three (continued):

const minScore = midtermScores.reduce(function(min, nextScore){
    return nextScore < min ? nextScore : min
})
	--we could also make this return the maximum score
	**Example Three (continued)

const maxScore = midtermScores.reduce(function(max, nextScore){
    return nextScore > max ? nextScore : max
})
	--all these examples of reduce are not using the optional second parameter of the reduce method
	--we can optionally pass in a value as the second argument
	--the argument will be used to initialize the accumulator
	--so instead of starting the accumulator as the first value in an array, we can set the accumulator that we want to start with
	--let's see how this would work
	--we want to find the lowest value of 2 separate arrays
	--we can use reduce to do this

	**Example Four:

const midtermScores = [ 88,70,93,94,64,62,56]
const finalsScores = [92,93,76,77,78,59,61]

const minOverallScore = finalsScores.reduce(function(min, nextScore){
    return nextScore < min ? nextScore : min
}, minMidtermScore);
	--here we used the minMidtermScore variable as the second parameter for our reduce method
	--this has now taken 2 separate arrays and found the lowest score between the two
**TO REVIEW
	--the reduce method can have 2 parameters
	--the first parameter is the accumulator and is not optional
	--the second (optional) parameter sets where the accumulator starts
	--it can be a function, it can be a value, it can be a variable
	--whatever we set it to be is where the reduce method will start iterating from

			11.25.10
			






















